<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[PingHackers]]></title>
  <subtitle><![CDATA[高质量原创技术博文分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://pinghackers.com/"/>
  <updated>2014-11-18T15:47:44.712Z</updated>
  <id>http://pinghackers.com/</id>
  
  <author>
    <name><![CDATA[Livoras]]></name>
    <email><![CDATA[me@livoras.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++学习之函数指针的使用及注意事项]]></title>
    <link href="http://pinghackers.com/2014/11/18/cpp-function-pointer/"/>
    <id>http://pinghackers.com/2014/11/18/cpp-function-pointer/</id>
    <published>2014-11-18T15:41:36.000Z</published>
    <updated>2014-11-18T15:45:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>背景介绍</li>
<li>函数指针基本知识</li>
<li>函数指针的注意事项</li>
<li>函数指针的用途</li>
<li>标准库与函数指针</li>
</ul>
<h2 id="背景介绍">背景介绍</h2>
<p>和老板聊天中，偶然谈到函数指针，惊觉自己在这方面的能力不足，偶尔以前也听潘炎教授谈到过函数指针的重要性，因此写下这篇博客。</p>
<p>在小型的工程代码中，函数指针的出镜率往往是非常小甚至是没有的。然而如果工程的规模比较大，则会发现函数指针会在多处使用。因此掌握函数指针对于每一个C++开发者来说都是一项必须的技能。</p>
<h2 id="函数指针基本知识">函数指针基本知识</h2>
<p>我们通过如下方法声明一个指向特定类型函数的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (* fp)(<span class="keyword">int</span>);                         <span class="comment">// pointer to a function</span></div></pre></td></tr></table></figure>

<p>要注意的是<strong>括号是不可缺少的</strong>，它表明fp是一个指向返回值为void的函数的指针，而不是返回值为void * 的函数。</p>
<p>函数指针既然是指针，就意味着它可以为空，否则它应该指向一个具有适当类型的函数，下面一段代码揭示了函数指针的使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> f ( <span class="keyword">int</span> );</div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> g ( <span class="keyword">long</span> );</div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> h (<span class="keyword">int</span> );</div><div class="line"></div><div class="line">fp = f ;               <span class="comment">//  Wrong! int (*)(int) instead of void (*)(int)</span></div><div class="line">fp = g ;               <span class="comment">//  Wrong! void (*)(long) instead of void (*)(int)</span></div><div class="line">fp = <span class="number">0</span> ;              <span class="comment">//  OK</span></div><div class="line">fp = h ;               <span class="comment">//  OK</span></div><div class="line">fp = &amp;h;              <span class="comment">//  OK, assign the address of the function explicitly to fp</span></div></pre></td></tr></table></figure>

<h2 id="函数指针的注意事项">函数指针的注意事项</h2>
<p>在上面的代码中，前面的三个函数声明很好理解，紧随其后的两行赋值代码会出错——由于类型的不匹配，而接下来的两行代码是简单的赋值，不会出问题。</p>
<p>需要注意的是最后一行代码……<strong>在函数指针中，讲一个函数的地址初始化或者赋值给一个指向函数的指针的时候，不需要显式使用&amp;符号取得函数的地址</strong>——编译器是知道隐式获得函数地址的。因此在这种情况下，&amp;操作符是可有可无的，一般来说是省略不用。</p>
<p>同样的，为了调用函数指针所指向的函数，我们也不需要对指针进行解引用，看下面两行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(* fp)( <span class="number">12</span> );           <span class="comment">//  explicit dereference</span></div><div class="line">fp(<span class="number">12</span> );                <span class="comment">//  OK, implicit dereference</span></div></pre></td></tr></table></figure>

<p>上面两种都是正确的操作。</p>
<p>对于数据来说，void<em> 指针可以指向任何类型的数据。可是对于函数来说，<strong>不存在可以指向任何类型函数的通用指针</strong>。此外值得一提的是，<em>*在一个类中的非静态成员函数的地址并不是一个指针</em></em>，因此不可以把一个函数指针指向一个非静态成员函数。这也就是为什么回调函数一般不会写在类里面的原因。</p>
<p>什么？你问我指向成员函数的指针是个什么东西？其实指向类中的指针应该是一个需要深入讨论的问题，这个今天不讨论，改天我找到女朋友了心情好了再写一篇博客<del>~^o^</del>~。不过大致的来讲可以把指向类中成员的指针视作一个偏移量，指向类中函数成员的指针通常可以被是视为一个包含了信息的结构。解引用又是一个蛋疼的问题，在这里就不讨论了……</p>
<h2 id="函数指针的用途">函数指针的用途</h2>
<p>函数指针的一种传统的用途是实现回调，也就是我们所说的callback函数（有兴趣的童鞋可以阅读设计模式中的command命令模式来深入了解回调技术）。所谓的一个回调函数就是一个可能的动作，而这个动作在初始化的时候就被设置好来应对将来可能发生的事情。</p>
<p>举个栗子，如果你饿了，那么我们如果希望对自己饿了这个情况作出反应，那么我们可以预先设定好我们的应对情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> eatApple ();</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> eatDumpling ();</div><div class="line"></div><div class="line"><span class="keyword">void</span> (* HungryAction )() = <span class="number">0</span> ;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( Hungry ){</div><div class="line">     <span class="keyword">if</span> ( gotKnife )</div><div class="line">        HungryAction = eatApple ;</div><div class="line">     <span class="keyword">else</span></div><div class="line">        HungryAction = eatDumpling ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果我们决定了要执行的动作，那么我们就可以在代码中的另一个部分专注于是否去执行操作以及何时去执行操作了，我们无需关心这个动作到底是吃苹果还是吃饺子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Hungry ){</div><div class="line">     <span class="keyword">if</span> ( HungryAction )</div><div class="line">        HungryAction ();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我在上面的函数中特意声明了一个内联函数，这是为了告诉大家，讲一个函数指针指向内联函数是完全合法的。但是，如果通过函数指针调用内联函数不会导致内联调用。这个原理其实很简单，因为编译器是无法在编译器就精确的确定将会调用什么函数的。在上面的例子中，HungryAction可能指向两个函数的任意一个，当然也可能是空的，因此在调用点，编译器只能生成间接非内联的函数调用机器代码。</p>
<p>还有要注意的地方（卧槽你有完没完！）……函数指针可以指向一个重载函数的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> eatApple ();</div><div class="line"><span class="keyword">void</span> eatApple (Knife knife );</div><div class="line">HungryAction = eatApple ;</div></pre></td></tr></table></figure>

<p>那么在不同的候选函数中，函数指针将在被使用的时候挑一个最匹配的。由于我们上面的函数类型是void (*)()，因此选择的是第一个eatApple()函数。</p>
<h2 id="标准库与函数指针">标准库与函数指针</h2>
<p>曾经看侯捷教授的《STL源码剖析》中看到，在STL标准库中，使用了函数指针用于回调机制的地方不能算少——最突出的就是被set_new_handler用于设置回调。</p>
<p>当new函数无法履行一个内存分配的请求（大部分原因是由于内存不足）时，就会调用到一个回调函数，用于报告此时的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> begForgiveness ()</div><div class="line">{</div><div class="line">    logError ( <span class="string">"I'm Sorry! "</span> );</div><div class="line">     <span class="keyword">throw</span> <span class="built_in">std</span> :: bad_alloc ();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">std</span> ::new_handler oldHandler = std:: set_new_handler ( begForgiveness );</div><div class="line"></div><div class="line">myHouse.add( <span class="keyword">new</span> girlFriend ( <span class="number">1000000000</span> ));</div></pre></td></tr></table></figure>

<p>吐槽代码你就输了……</p>
<p>BTW，标准类型的名称中的new_handler实际上就是一个typedef：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*new_handler )();</div></pre></td></tr></table></figure>

<p>因此，回调函数必须是一个不带参数并且返回void的函数。set_new_handler函数会将回调设置为参数，并且返回前一个回调，这也就是所谓的获得当前回调的“回旋式手法”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span> ::new_handler current = std:: set_new_handler (<span class="number">0</span> );      <span class="comment">//   获取</span></div><div class="line"><span class="built_in">std</span> ::set_new_handler ( current );                           <span class="comment">//   恢复</span></div></pre></td></tr></table></figure>

<p>扯一句题外话，set_terminate和set_unexpected也是使用了这种回旋手法……不过还是等到找到第二个女朋友再扯这个话题吧……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>背景介绍</li>
<li>函数指针基本知识</li>
<li]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之RAII编程思想]]></title>
    <link href="http://pinghackers.com/2014/11/16/cpp-raii/"/>
    <id>http://pinghackers.com/2014/11/16/cpp-raii/</id>
    <published>2014-11-16T15:27:39.000Z</published>
    <updated>2014-11-18T15:39:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>背景介绍</li>
<li>先说一点C++</li>
<li>总体概念<ul>
<li>举个RAII栗子</li>
<li>实际操作之反栗 </li>
<li>实际操作之正栗</li>
</ul>
</li>
</ul>
<h2 id="背景介绍">背景介绍</h2>
<p>在C++程序运行的过程中免不了要进行资源的分配——尤其是在游戏中！资源可以有很多种，从纹理、声音、着色器代码到句柄、字符串这些东西都可以被称为资源。资源的管理是项目中很重要的一轮，做得不好的话轻则内存泄漏、重则内存崩溃。RAII则是在C++项目中用于资源管理的一种重要的编程思想。</p>
<a id="more"></a>

<h2 id="先说一点C++">先说一点C++</h2>
<p>C++中不可或缺的东西就是class，而每个class不可或缺的就是构造函数和析构函数。前者用于对象被构造时进行的一系列操作，后者用于对象被析构时所执行的函数。</p>
<p>而值得一提的是，在C++中，如果一个类被声明在栈空间，则在该函数执行完毕从栈空间弹出之后，类会自动调用析构函数。可是如果被显示声明在堆空间（使用new方法或者malloc方法），则需要显式调用析构函数才能进行析构。</p>
<p>以上就是要读懂本篇博客所需要的C++知识，应该不难吧……</p>
<h2 id="总体概念">总体概念</h2>
<p>C++有很多很奇葩的名字，比如yacc，raii等，这算是一种悠久而自豪的传统吧2333333。</p>
<p>RAII是一个很典型的例子，它表示的是“资源获取即初始化”(Resource Aquisition Is Initialization)，而不是某些人认为的“初始化即资源获取”(Initialization is resource acquisition)。BTW，如果想搞怪，就怪到底吧，不然达不到效果。</p>
<p>RAII的技术很简单，利用C++对象生命周期的概念来控制程序的资源。它的技术原理很简单，如果希望对某个重要资源进行跟踪，那么创建一个对象，并将资源的生命周期和对象的生命周期相关联。这样一来C++自带的对象管理设施就可以来管理资源了。</p>
<h3 id="举个RAII栗子">举个RAII栗子</h3>
<p>最简单的形式：创建一个对象，让她的构造函数获取一份资源，而析构函数则释放这个资源：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Resource{...};</div><div class="line"><span class="keyword">class</span> ResourceHandle{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">         <span class="comment">// get resource</span></div><div class="line">         <span class="keyword">explicit</span> ResourceHandle(ResourceHandle *aResource ): r_(aResource){}</div><div class="line">        </div><div class="line">         <span class="comment">// release resource</span></div><div class="line">         ~ResourceHandle()</div><div class="line">         {</div><div class="line">             <span class="keyword">delete</span> r_;</div><div class="line">         }</div><div class="line">        </div><div class="line">         <span class="comment">// get access to resource</span></div><div class="line">        Resource *get()</div><div class="line">         {</div><div class="line">             <span class="keyword">return</span> r_;</div><div class="line">         }</div><div class="line">        </div><div class="line">    <span class="keyword">private</span>:</div><div class="line">         <span class="comment">// make sure it can not be copied by others</span></div><div class="line">        ResourceHandle (<span class="keyword">const</span> ResourceHandle &amp;);</div><div class="line">        ResourceHandle &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ResourceHandle &amp;);</div><div class="line">        Resource *r_;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>ResourceHandle对象的最好的地方就是：如果它被声明为一个函数的局部变量，或者作为一个参数，或者静态变量，我们都可以保证析构函数得到调用了。这样一来就可以释放对象所引用的资源。</p>
<h3 id="实际操作之反栗">实际操作之反栗</h3>
<p>我们看看一个没有使用RAII的简单代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> f() {</div><div class="line"></div><div class="line">    Resource *rh = <span class="keyword">new</span> Resource;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">if</span> (blahblah())</div><div class="line">         <span class="keyword">return</span> ;</div><div class="line">        </div><div class="line">    <span class="comment">//...</span></div><div class="line">    g();         <span class="comment">//catch the exceptions</span></div><div class="line">    </div><div class="line">    <span class="comment">// Can we make sure that it can be processed here?</span></div><div class="line">    <span class="keyword">delete</span> rh ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>就如同我在注释中的一样，可能一开始的时候上面那段代码是安全的，rh的资源总是可以被释放。</p>
<p>但是如果经历了一些维护呢？比如说上面的g()函数，有可能会造成函数的提前返回，所以就有可能运行不到最后一句释放资源的代码了，因此这段代码是危险的。</p>
<h3 id="实际操作之正栗">实际操作之正栗</h3>
<p>那么如果使用RAII的话呢？代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> f() {</div><div class="line"></div><div class="line">    ResourceHandle rh (<span class="keyword">new</span> Resource );</div><div class="line">    </div><div class="line">    <span class="comment">//Definitely ok</span></div><div class="line">    <span class="keyword">if</span> (blahblah())</div><div class="line">         <span class="keyword">return</span> ;</div><div class="line">    </div><div class="line">    <span class="comment">//catch an exception? Go ahead!</span></div><div class="line">    g();</div><div class="line">    </div><div class="line">    <span class="comment">//finally the resource would be released by c++ itself.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样一来RAII就使得代码就更加健壮了，因为只要是函数返回了，无论是通过何种途径，那么在返回的时候析构函数就会自动释放资源。</p>
<p>使用RAII只有一种情况无法保证析构函数得到调用，就是当ResourceHandle被动态分配到堆空间上了，这样一来就只能显示得调用delete ResourceHandle对象才能保证资源释放了，比如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResourceHandle *rhp = <span class="keyword">new</span> ResourceHandle(<span class="keyword">new</span> Resource);    </div></pre></td></tr></table></figure>

<p>那么此时就蛋疼了，因为动态分配的东西需要显示调用delete才能释放，所以上面的做法通常是危险的做法。安全的做法是将RAII的handle分配到栈空间去，此时就能够确保安全。</p>
<p>（全文完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>背景介绍</li>
<li>先说一点C++</li>
<li>总体概念<ul>
<li>举个RAII栗子</li>
<li>实际操作之反栗 </li>
<li>实际操作之正栗</li>
</ul>
</li>
</ul>
<h2 id="背景介绍">背景介绍</h2>
<p>在C++程序运行的过程中免不了要进行资源的分配——尤其是在游戏中！资源可以有很多种，从纹理、声音、着色器代码到句柄、字符串这些东西都可以被称为资源。资源的管理是项目中很重要的一轮，做得不好的话轻则内存泄漏、重则内存崩溃。RAII则是在C++项目中用于资源管理的一种重要的编程思想。</p>
]]>
    
    </summary>
    
      <category term="C++" scheme="http://pinghackers.com/tags/C/"/>
    
      <category term="game" scheme="http://pinghackers.com/tags/game/"/>
    
      <category term="RAII" scheme="http://pinghackers.com/tags/RAII/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web前后端分离开发思路]]></title>
    <link href="http://pinghackers.com/2014/11/16/front-and-back-seperation-development/"/>
    <id>http://pinghackers.com/2014/11/16/front-and-back-seperation-development/</id>
    <published>2014-11-15T16:50:44.000Z</published>
    <updated>2014-11-16T15:55:26.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="1-_问题的提出">1. 问题的提出</h2>
<p>开发一个Web应用的时候我们一般都会简单地分为前端工程师和后端工程师（注：在一些比较复杂的系统中，前端可以细分为外观和逻辑，后端可以分为CGI和Server）。前端工程师负责浏览器端用户交互界面和逻辑等，后端负责数据的处理和存储等。前后端的关系可以浅显地概括为：后端提供数据，前端负责显示数据。</p>
<p>在这种前后端的分工下，会经常有一些疑惑：<strong>既然前端数据是由后端提供，那么后端数据接口还没有完成，前端是否就无法进行编码？怎么样才能做到前后端独立开发？</strong></p>
<a id="more"></a>

<p>考虑这么一个场景：Alex和Bob是一对好基友，他们有个可以颠覆世界的idea，准备把它实现出来，但是他们不需要程序员，因为他们就是程序员。说干就干，两个就干上了。Alex写前端，Bob写后端。</p>
<p>Alex和Bob都经过良好的训练，按部就班地把产品的主要功能设计，交互原型，视觉设计做好了，然后他们根据产品功能和交互制定了一堆叼炸天的前后端交互的API，这套API就类似于一套前后端开发的“协议”，Alex和Bob开发的时候都需要遵守。例如其中一个发表评论的功能：</p>
<pre><code>// <span class="type">API</span>: <span class="type">Create</span> <span class="type">New</span> <span class="type">Comment</span> v2
// <span class="type">Ajax</span>, <span class="type">JSON</span>, <span class="type">RESTful</span>
url: /comments
<span class="keyword">type</span>: <span class="type">POST</span>
request: {content: <span class="string">"comment content."</span>, userId: <span class="number">123456</span>}
response: 
    - status: <span class="number">200</span>
        data: {<span class="literal">result</span>: <span class="string">"SUCCESS"</span>, msg: <span class="string">"The comment has been created."</span>}
    - status: <span class="number">404</span>
        data: {<span class="literal">result</span>: <span class="string">"failed"</span>, msg: <span class="string">"User is not found."</span>}
</code></pre><p>Alex的前端需要向<code>/comments</code>这个url以<code>POST</code>的方式发送类似于<code>{content: &quot;comment content.&quot;, userId: 123456}</code>这样的JSON请求数据；Bob的服务端识别后以后，操作成功则返回200状态和上面的JSON的数据，不同的操作状态有不同的响应数据（为了简单起见只列出了两种，200和404）。</p>
<p>API制定完以后，Alex和Bob就开始编码了。Alex把评论都外观和交互写完了，但是写到发表评论功能就纳闷了：Alex现在需要发Ajax过去，但是只能把Ajax代码写好，因为是本地服务器，却无法获取到数据：</p>
<pre><code>// jQuery <span class="type">Ajax</span>
$.ajax({ // 这个ajax直接报错，因为这个是<span class="type">Alex</span>的前端服务器，请求无法获取数据；
    url: <span class="string">"/comments"</span>,
    <span class="typedef"><span class="keyword">type</span>: "<span class="type">POST</span>",</span>
    <span class="typedef"><span class="keyword">data</span>: <span class="container">{<span class="title">content</span>: <span class="title">content</span>, <span class="title">userId</span>: <span class="title">userId</span>}</span>,</span>
    success: funtion(<span class="typedef"><span class="keyword">data</span>) <span class="container">{
        // 这里不会被执行
    }</span></span>
})
</code></pre><p>相比起来Bob就没有这个烦恼，因为后端是基于测试驱动开发，且后端可以轻易地模拟前端发送请求，可以对前端没有依赖地进行开发和测试。</p>
<p>Alex把这种情况和Bob说了，Bob就说，要不我们把代码弄到你本地前后端连接一下，这不就可以测试了吗。Alex觉得Bob简直是天才。</p>
<p>他们把前后端代码代码都部署到Alex的本地服务器以后，经过一系列的测试，调试，终于把这个API连接成功了。但是他们发现这个方法简直不科学：难道每写一个API都要把前后端链接测试一遍吗？而且，Alex的如果需要测试某个API，而Bob的这个API还没写好，Alex这个功能模块的进度就“阻塞”了。</p>
<p>后面还有168个API需要写，不能这么做。Alex和Bob就开始思考这个问题的解决方案。</p>
<h2 id="2-_解决思路">2. 解决思路</h2>
<p>在这个场景下，前后端是有比较强的数据依赖的关系，后端依赖前端的请求，前端依赖后端的响应。而后端可以轻松模拟前端请求（基本上能写后端的语言都可以直接发送HTTP请求），前端没有一个比较明显的方案来可以做到模拟响应，所以这里的需要解决的点就是：<strong>如何给前端模拟的响应数据</strong>。</p>
<p>先来一句非常形而上的话：如果两个对象具有强耦合的关系，我们一般只要引入第三个对象就可以打破这种强耦合的关系。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">Object1</span> <span class="comment">|</span>  &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">|</span> <span class="comment">Object2</span> <span class="comment">|</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>

               <span class="comment">Before</span>               


<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">Object1</span> <span class="comment">|</span>  &lt;<span class="literal">-</span><span class="literal">-</span> <span class="comment">✕</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">|</span> <span class="comment">Object2</span> <span class="comment">|</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>       <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>        <span class="comment">|</span>    
    <span class="comment">|</span>       <span class="comment">|</span>         <span class="comment">|</span>        <span class="comment">|</span>    
    <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span> <span class="comment">Object3</span> <span class="comment">|</span> &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>    
            <span class="comment">|</span>         <span class="comment">|</span>             
            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>             

               <span class="comment">After</span>                
</code></pre><p>在我们上述开发的过程中，前后端的耦合性太强了，我们需要借助额外的东西来打破它们的耦合性。所以，在前后端接口定下来以后，<strong>我们根据接口构建另外一个Server，这个Server会一一响应前端的请求，并且根据接口返回数据</strong>。当然这些数据都是假数据。我们把这个Server叫做<em>Mock Server</em>，而Bob真正在开发的Server叫做<em>Real Server</em>。</p>
<pre><code>+-------------------+                     +-------------------+
<span class="string">|                   | +-------- ✕ ------&gt; |                   |</span>
<span class="string">|     Browser       |                     |    Real Server    |</span>
<span class="string">|                   | &lt;---+               |                   |</span>
+--------------+----+     <span class="string">|               +-------------------+</span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
           Request      Response                               
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|     +----+--------------+                     </span>
               +---&gt; <span class="string">|                   |                     </span>
                     <span class="string">|    Mock Server    |                     </span>
                     <span class="string">|                   |                     </span>
                     +-------------------+                     
</code></pre><p>Mock Server是根据API实现的，但是是没有数据逻辑的，只是非常简单地返回数据。例如上面Alex和Bob的发表评论的接口在Mock Server上是这样的：</p>
<pre><code>// <span class="type">Mock</span> <span class="type">Server</span>
// <span class="type">Create</span> <span class="type">New</span> <span class="type">Comment</span> <span class="type">API</span>
route.post(<span class="string">"/comments"</span>, function(req, res) {
    res.send(<span class="number">200</span>, {<span class="literal">result</span>: <span class="string">"Success"</span>});
})
</code></pre><p>Alex在开发的时候向Mock Server发出请求，而不是向Bob的服务器发出请求：</p>
<pre><code>// <span class="type">Sending</span> <span class="type">Request</span> to <span class="type">Mock</span> <span class="type">Server</span>
// jQuery <span class="type">Ajax</span>
$.ajax({ 
    url: config.<span class="type">HOST</span> + <span class="string">"/comments"</span>,
    <span class="typedef"><span class="keyword">type</span>: "<span class="type">POST</span>",</span>
    <span class="typedef"><span class="keyword">data</span>: <span class="container">{<span class="title">content</span>: <span class="title">content</span>, <span class="title">userId</span>: <span class="title">userId</span>}</span>,</span>
    success: funtion(<span class="typedef"><span class="keyword">data</span>) <span class="container">{
        // <span class="type">OK</span>
    }</span></span>
})
</code></pre><p>注意上面的<code>config.HOST</code>，我们把服务器配置放在一个全局共用的模块当中：</p>
<pre><code><span class="comment">// Front-end Configuration Module</span>
<span class="keyword">var</span> config = modules.exports;
config.HOST = <span class="string">"http://192.169.10.20"</span> <span class="comment">// Mock Server IP</span>
</code></pre><p>那么上面我们其实是向IP为<code>http://192.169.10.20</code>的Mock Server发出请求<code>http://192.169.10.20/comments</code>发出POST的请求。</p>
<p>当Alex和Bob都代码写好了以后，需要连接调试了，Alex只要简单地改一下配置文件即可把所有的请求都转向Bob所开发的Real Server：</p>
<pre><code><span class="comment">// Front-end Configuration Module</span>
<span class="keyword">var</span> config = <span class="built_in">module</span>.exports;
<span class="comment">// config.HOST = "http://192.169.10.20" // Mock Server IP</span>
config.HOST = <span class="string">"http://changing-world-app.com"</span> <span class="comment">// Real Server Domain</span>
</code></pre><p>然后Alex和Bob就可以愉快地分离独立开发，而最后只需要联合调试就可以了。</p>
<p>总结一下基本上前后端分离开发包括下面几个步骤：</p>
<ol>
<li>根据功能制定前后端接口（API）。</li>
<li>根据接口构建Mock Server工程及其部署。</li>
<li>前后端独立开发，前端向Mock Server发送请求，获取模拟的数据进行开发和测试。</li>
<li>前后端都完成后，前后端连接调试（前端修改配置向Real Server而不是Mock Server发送请求）。</li>
</ol>
<p>当然要注意，如果接口修改了，Mock Server要同步修改。</p>
<h2 id="3-_实现方案">3. 实现方案</h2>
<p>Mock Server具体应该如何构建？应该存放在哪里？应该怎么维护？</p>
<p>前后端是不同的两个工程，它们各自占用一个仓库。Mock Server应该和它们分离出来，独立进行开发和维护，也就是说会有三个仓库，Mock Server是一个单独的工程。</p>
<p>Mock Server可以部署在本地，也可以部署到远程服务器，两者之间各有优劣。</p>
<hr>
<h3 id="3-1_远程Mock_Server">3.1 远程Mock Server</h3>
<p><strong>做法</strong>：把Mock Server工程部署到一个远程的always on的远程服务器上，前端开发的时候向该服务器发请求。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>没有给原有的前后端工程增加负担。</li>
<li>每个前端开发人员向同一个Mock Server服务器发送请求，保持所有人获取响应请求的一致性。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>有跨域问题（思考：locahost如何向192.169.10.20发请求？）。</li>
<li>需要额外的远程服务器支持。</li>
</ol>
<p>（在写这篇博客的时候，逛<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>，刚好看到有人做了一个开发辅助工具（<a href="http://reqr.es/" target="_blank" rel="external">http://reqr.es/</a>），可以用于开发时响应前端请求，其实也就是这里所说的远程Mock Server。真是不能再巧更多。）</p>
<h3 id="3-2_本地Mock_Server">3.2 本地Mock Server</h3>
<p><strong>做法</strong>：前端把Mock Server克隆到本地，开发的时候，开启前端工程服务器和Mock Server，所有的请求都发向本地服务器，获取到Mock数据。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>节约资源，不需要依赖远程服务器。环保节能。</li>
<li>没有跨域问题。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>增加前端工程开发流程复杂程度。</li>
<li>每个前端开发人员自己部署服务器在本地，可能会有仓库没有及时更新导致API不一致的情况。</li>
</ol>
<hr>
<p>Mock Server工程一般可以由后端开发人员来维护。因为在开发的过程中，后端因为各种原因可能需要修改API，后端人员是最熟悉请求的响应数据和格式的人，可以同步维护Mock Server和Real Server，更好保证数据的一致。Mock Server维护起来并不复杂，对于比较大多工程来说，这样的前期准备和过程的维护是非常值得的。</p>
<h2 id="最后">最后</h2>
<p>所以要点就是：<strong>根据API构建可以模拟服务器响应的Mock Server，用于前端请求模拟数据进行测试</strong>。</p>
<p>再重复总结一下前后端分离开发包括下面几个步骤：</p>
<ol>
<li>根据功能制定前后端接口。</li>
<li>根据接口构建Mock Server工程及其部署。</li>
<li>前后端独立开发，前端向Mock Server发送请求，获取模拟的数据进行开发和测试。</li>
<li>前后端都完成后，前后端连接调试。</li>
</ol>
<p>当开发只有我一个人的时候，我更喜欢后端独立开发，开发前端的时候开个Real Server来做响应。又爽又快。其实如果团队的人是full-stack的话，完全可以按照功能模块来划分任务，而不是分为前端工程师和后端工程师。</p>
<p>但一般来说还是会选择前后端职能划分，对于这种情况下的多人开发的工程来说，前后端分离开发的方式确实需要考虑和构建的，可以更好帮助我们构建一个高效，规范化，流程化的开发流程。</p>
<p>还是那句话，没有银弹，所有的东西都需要根据实际情况来构建独特的流程。</p>
<h2 id="References">References</h2>
<p> 无</p>
<p>（全文完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="1-_问题的提出">1. 问题的提出</h2>
<p>开发一个Web应用的时候我们一般都会简单地分为前端工程师和后端工程师（注：在一些比较复杂的系统中，前端可以细分为外观和逻辑，后端可以分为CGI和Server）。前端工程师负责浏览器端用户交互界面和逻辑等，后端负责数据的处理和存储等。前后端的关系可以浅显地概括为：后端提供数据，前端负责显示数据。</p>
<p>在这种前后端的分工下，会经常有一些疑惑：<strong>既然前端数据是由后端提供，那么后端数据接口还没有完成，前端是否就无法进行编码？怎么样才能做到前后端独立开发？</strong></p>
]]>
    
    </summary>
    
      <category term="web" scheme="http://pinghackers.com/tags/web/"/>
    
      <category term="流程" scheme="http://pinghackers.com/tags/%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端自动化开发工作流模板]]></title>
    <link href="http://pinghackers.com/2014/11/08/front-end-workflow/"/>
    <id>http://pinghackers.com/2014/11/08/front-end-workflow/</id>
    <published>2014-11-08T02:00:24.000Z</published>
    <updated>2014-11-16T15:55:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="1-_前言">1. 前言</h2>
<p>HTML5在前几天终于成为了W3C推荐的标准，让Web开发者们非Web开发者们和不知道是什么但是看起来很厉害于是一起起哄的人高潮了一顿，普天同庆。</p>
<p>其实没什么好high的，在2008年HTML5就完成了draft。早在2011年W3C就设了一个2014年完成标准的milestone。我大一毛都没长齐的时候就听师兄们说：”你毕业的时候HTML5就会完成并成为标准啦啦啦。” W3C只是完成了它们的计划而已。而且，这几年人们早就都把HTML5、CSS3用得出神入化了。</p>
<p>不过随着HTML5、ES6这些东西成为标准，还有最近世界上聪明的头脑们在Web方面进行的先烈和先驱般的探索，层出不穷的新语言、新技术、新框架，原来混沌的世界逐渐被开辟出一片天地。原来杂乱无章的Web前端开发过程也叫嚷着要规范化、标准化。随着众神们的努力，我相信很快，我们写一次前端代码就可以完美地在除了IE以外的各个浏览器中运行（脑洞有点大）。</p>
<p>扯得有点远，其实上面说的内容和我要介绍的东西无关。本文会介绍我常用的一种前端开发工作流程，并且提供一个模板，有兴趣的同学可以修改成适合自己的。</p>
<h2 id="2-_前端自动化工作流简介">2. 前端自动化工作流简介</h2>
<p>每种项目都有自己特定的开发流程、工作流程。从需求分析、设计、编码、测试、发布，一个整个开发流程中，会根据不同的情况形成自己独特的步骤和流程。一个工作流的过程不是一开始就固定的，而是随着项目的深入而不断地改进，期间甚至会形成一些工具。例如当年大神们在Linux写C语言，觉得每次编译好多文件好麻烦，就发明了makefile。不同代码的管理好麻烦，然后就发明了git、SVN等等。</p>
<p>一个工作流程的好坏会影响你开发的效率、开发的流程程度，然后间接影响心情，打击编码积极性。所以我认为开发一个项目的时候，编码前把工作流程梳理清楚确定下来是一个非常重要的步骤。并且这个流程要在真实环境中不停的改进。</p>
<p>对于要负责页面结构和内容、外观、逻辑的前端来说，一个好的工作流至关重要。而且这里中没有银弹。要根据具体项目所使用的框架、应用场景来进行调整独特的工作流。</p>
<p>我会介绍一个我经常使用的前端工作流，这个工作流只是一个原始的流程，一般来说，我会根据不同项目的不同来在这个基础上进行调整，形成每个项目独特的流程。所以这里的重点是领会构建工作流的思路，然后学会举一反三。</p>
<p>一个前端自动化开发流程中，我觉得至少需要做到以下几点：</p>
<ol>
<li>良好的模块化</li>
<li>自动化编译</li>
<li>自动化测试</li>
<li>实时刷新页面</li>
<li>自动化打包、压缩发布</li>
</ol>
<p>能用机器的地方就不要自己动手，除了上述必备的几点，有时候要根据特定的情况编写一些Python、Nodejs、Shell脚本来避免重复的操作。好好呵护你的F5和稀疏的脑神经，男人要对自己好一点。</p>
<a id="more"></a>

<h2 id="3-_储备知识">3. 储备知识</h2>
<p>在正式介绍之前会先做一些储备知识的介绍，也会略过一些你可能不懂的知识。懂的话可以跳过，遇到不懂的可以自己Google，不要百度。</p>
<h3 id="3-1_工程目录">3.1 工程目录</h3>
<p>我的工程目录一般是这个样的：</p>
<pre><code>├─assets/
│  └─images/
├─bin/
├─dist/
├─lib/
├─src/
│  ├─coffee/
│  │  └─main.coffee
│  └─less/
│     └─main.less
├─test/
│   └─specs/
├─node_modules/
├─<span class="keyword">index</span>.html
├─Gruntfile.coffee
├─<span class="keyword">package</span>.json
├─.gitignore
└─README.md
</code></pre><p>所有子目录名称很多都其实源于古老的C语言工程。</p>
<p><strong>assets</strong>：一般存放的是图片、音频、视频、字体等代码无关的静态资源，我一般只有图片，有时候也会新建一个fonts文件夹什么的。</p>
<p><strong>bin</strong>：binary的缩写，这个名字来历于我们古老的C语言工程，因为一般C语言要编译成可执行的二进制文件什么的，后来基本成为了一种默认的标注。所以前端编译好的文件也会存放在bin/目录下。</p>
<p><strong>dist</strong>：distribution的缩写，编译好的bin中的文件并不会直接用于发布，而是会经过一系列的优化操作，例如打包压缩等。最终能够部署到发布环境的文件都会存放在dist里面，所以dist里面是能够直接用到生产环境的代码。</p>
<p><strong>lib</strong>：library的缩写，存放的是第三方库文件。例如你喜欢的jquery、fastclick什么的。但是接下来你会看到，在我们的模块化方式中，这个文件夹一般是比较鸡肋的存在。</p>
<p><strong>src</strong>：source的缩写，所有需要开发的源代码的存放地，我们一般操作地最多的就是这个文件夹。简单地分为coffee、less两个文件夹，存的是逻辑代码和样式（我一般用CoffeeScript和LessCss，当然你也可以改成你喜欢的语言，JS，TS，LS，SASS，思路是一样的）。你看到两个文件夹下分别有main.coffe、main.less，这其实是逻辑代码和样式代码的主要入口文件，会把其他模块和样式引进来，通过某种机制合成一个文件。接下来会详细解释。</p>
<p>另外，这个目录的组织方式会根据实际情况多变。有时候你会需要html模板，可能会多一个tpl/目录。也许你的目录不是这种基于文件类型的层次组织，而是基于页面部件的组织，就可能出现components/目录，然后下面有很多个页面部件的目录，每个子目录有自己的coffee、less、html。（这种形式也变得逐渐流行。因为基于文件类型目录，当工程复杂起来的时候，就会变得异常难以维护，基于部件就会相当方便）。</p>
<p><strong>test</strong>：使用测试驱动（TDD）开发进行编程，这里存放的都是测试样例。</p>
<p><strong>index.html</strong>：页面文件</p>
<p>接下来几个文件都不解释，不了解的可以先预习NodeJS、Git、Grunt这几个东西。</p>
<h3 id="3-2_模块化">3.2 模块化</h3>
<p>说起前端模块化又是一个可以长篇大论话题。前端模块化的方式有很多种，年轻人最喜欢用的就是RequireJS、SeaJS什么的，看到这些模块化工具的时候感觉就像自己的第一双滑板鞋那样那么兴奋。其实这种AMD、CMD都需要引进一个库文件来做模块化工具，而且配置复杂，各种异步加载问题多多。后来我发现其实最clean、直接、方便、强大模块化方式当属<a href="http://substack.net" target="_blank" rel="external">substack</a>大神的真.<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>。</p>
<p><img src="http://browserify.org/images/browserify.png" alt="block"></p>
<p>它可以基于NodeJS平台实现模块化的工具，你可以像组织NodeJS代码那样组织自己的前端工程，所有的模块都可以像NodeJS那样直接require进来。提供一个入口文件（如上的main.coffee)给Browserify，它会把这个入口文件的所有依赖模块都打包成一个文件。最终的文件不依赖于Browserify，最终的文件就是你的逻辑代码的组合。</p>
<p>而且Browserify和NodeJS的模块兼容性很好，一些NodeJS自带的模块例如util、path都可以用到前端中。你用npm安装的库，也可以通过Browserify用到前端中！例如我想用jQuery，我只需要：<code>npm install jquery --save</code>。然后在main.coffee中：</p>
<pre><code><span class="variable">$ </span>= <span class="keyword">require</span> <span class="string">"jquery"</span>
/<span class="regexp">/ play with jquery</span>
</code></pre><p>相当贴心。</p>
<p>（Browserify具体用法查看<a href="http://browserify.org/" target="_blank" rel="external">官网文档</a>）</p>
<h3 id="3-3_流程自动化工具">3.3 流程自动化工具</h3>
<p>其实自动化方式可以有很多种，你可以：</p>
<ul>
<li>配置npm的script，直接用npm来进行自动化任务管理。</li>
<li>使用古老的makefile和shell脚本</li>
<li>Grunt</li>
<li>Gulp</li>
</ul>
<p>前两种方式更适合NodeJS开发服务端的应用场景，前端一般更适合用后两种。</p>
<p>目前使用的是<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>，选择它是因为它社区大、插件多、成熟。但是我更看好Gulp基于流(Stream)的机理，这种继承于Unix思想的无与伦比的实现方式着实可以让它在性能上和Grunt拉开差距。Grunt基于文件实现方式是在是：太！慢！了!</p>
<p>（Grunt具体用法可以见<a href="http://gruntjs.com/" target="_blank" rel="external">官网文档</a>）</p>
<h3 id="3-4_测试">3.4 测试</h3>
<p>测试又是一个庞大的话题。在国外，前端TDD、BDD开发已经相当成熟，各种酷炫的工具Jasmine、Mocha、Tape等等，可能是我比较孤陋寡闻，貌似国内很少见到这些工具的使用。</p>
<p>其实前端是很难做到完全测试驱动开发的，它本身涉及到许多主观判断因素，例如动画是不是按照预想的那样移动等等。但是<strong>逻辑代码</strong>和<strong>前后端接口</strong>逻辑是可以测试的。所以引进测试驱动开发的一个非常大的好处就是：只要接口确定了，前后端可以分离开发，前端不用再“等后端API实现”了。</p>
<p>在我们的工作流中，使用<a href="http://mochajs.org/" target="_blank" rel="external">MochaJS</a>作为测试套件，<a href="http://chaijs.com/" target="_blank" rel="external">ChaiJS</a>作为断言库，<a href="http://sinonjs.org/" target="_blank" rel="external">Sinon</a>做为数据mocking和函数spy。具体用法可以看各自的官网。</p>
<p>（对前端测试驱动开发不了解的同学可以Google相关资料或查阅相关书籍）</p>
<h2 id="4-_自动化工作流">4. 自动化工作流</h2>
<h3 id="4-1_模板">4.1 模板</h3>
<p>这个工作流的模版已经存放到了github上，大家可以clone下来进行本地测试一下：<a href="https://github.com/livoras/feb.git" target="_blank" rel="external">https://github.com/livoras/feb.git</a></p>
<p>运行步骤：</p>
<ol>
<li>电脑上必须先按安装好Nodejs和npm</li>
<li><p>安装browswerify，coffeescript，和grunt：</p>
<p> npm install browswerify coffee-script grunt-cli -g</p>
</li>
<li><p>把仓库fork到本地，进入工程目录，安装依赖：</p>
<p> npm install</p>
</li>
<li><p>然后运行grunt命令</p>
</li>
</ol>
<p>运气好的话你可以看到这样的界面:</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/grunt.png"></p>
<p>然后，你会发现工程目录下多了一个bin文件夹，那就是我们刚编译好的文件存放在bin中。</p>
<p>然后打开浏览器，进入<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> ，可以看到：<br><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/localhost.png"></p>
<p>现在我们修改src/less/main.less文件，把body改成黑色看看：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/less.png"></p>
<p>然后回到浏览器看看：<br><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/black-localhost.png"></p>
<p>说变就变，非常哦妹子（amazing）是不是？</p>
<p>工作流分两个简单的步骤：</p>
<ol>
<li>开发时</li>
<li>分布时 </li>
</ol>
<p>现在来介绍一下。</p>
<h3 id="4-2_开发时">4.2 开发时</h3>
<p>我们来看看gruntfile的100～108行：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/gruntfile.png"></p>
<p>其实grunt干了这么几件事：</p>
<ol>
<li><strong>开启本地服务器进行调试</strong>：使用grunt的一个connect插件，开启了一个本地服务器，localhost:3000，工程目录为根目录。</li>
<li><strong>删除原来已经之前已经过时的编译文件</strong>：删除整个bin文件夹</li>
<li><strong>编译coffeescript并且使用browserify进行依赖合并</strong>：将src/coffee/下面的main.coffee作为入口，把所有依赖模块编译成js并且合并成一个文件，存放到bin/js/目录下。打开bin/js/你可以看到下面有一个main.js。细心但话，你会发现，其实main.coffee是依赖同目录下的一个叫another-module.coffee的模块的。在编译的时候，browserify会分析整个main.coffee的依赖树，然后找到所有依赖进行合并，所以你看到的bin/js/main.js其实是包含了两个模块的内容。所以我们可以用Nodejs的方式写模块，前端只需要合并好的文件就可以了。</li>
<li><strong>编译less</strong>：将src/less/main.less编译到bin/css/目录下，同样的， Less也是可以类似coffee的方式引用模块（通过<code>import</code>）。所以我们的样式也是萌萌哒模块化了。</li>
<li><strong>运行测试</strong>：所有的测试存放在test/specs下，编译好以后，grunt会运行moch运行测试样例。你在窗口中可以看到我们一共有三个测试运行并且通过了。</li>
<li><strong>监控文件变化，一旦文件变化，重新执行3～5步骤。并且自动刷新浏览器</strong>：借助于grunt的watch插件，我们可以做到一旦文件修改的时候，就重新编译coffeescript，less，运行测试，并且自动刷新浏览器。</li>
</ol>
<p>有了这么一个流程，你就可以很轻松地写前端的逻辑和样式，并且都是以模块化的方式。</p>
<h3 id="4-3_发布时">4.3 发布时</h3>
<p>好了，代码都写完了。我需要把我的代码部署到服务器上。很简单，只需要命令行中执行：</p>
<pre><code><span class="title">grunt</span> build
</code></pre><p>你就会发现工程目录下多了一个dist文件夹，进入里面，可以看到：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/dist.png"></p>
<p>直接打开index.html：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/dist-index.png"></p>
<p>居然可以直接打开，也是非常哦妹子是不是？</p>
<p>我们看看grunt的build任务：<br><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/grunt-build.png"></p>
<p>grunt build干了这么几件事情：</p>
<ol>
<li>删除之前编译过的文件，同上。</li>
<li>删除之前发布的文件，也就是删除整个dist目录。</li>
<li>编译coffee和less，同上。</li>
<li>测试，发布前还是需要看看有没有问题嘛。</li>
<li>uglify，把bin/js/main.js混淆压缩，放到dist/js/下。</li>
<li>cssmin，把bin/css/main.css混淆压缩，放到dist/css下。</li>
<li>复制assets目录到dist下</li>
<li>复制index.html，做一些处理（更改相对路径等），存放到dist/下</li>
</ol>
<p>你可以看到dist目录下的文件js和css文件都是经过压缩的，现在dist中的文件夹已经ready了，你随时都可以直接放到服务器上了。</p>
<h2 id="5-_最后">5. 最后</h2>
<p>上面其实是一个非常简陋的流程，在实际要做的流程化要比这个复杂多，例如要考虑组建目录自动化构建，版本管理自动化，部署自动化，图片合并优化等等。主要有这个意识：<em> <strong>不要做任何重复的工作，能自动化到地方都可以想法设法做到自动化</strong> </em>。</p>
<p>上面也跳过了很多基础知识，这些是你需要知道的：</p>
<ol>
<li>Grunt的使用</li>
<li>Nodejs的基本使用</li>
<li>模块化概念</li>
<li>TDD测试的概念和基本测试套件的使用</li>
<li>Coffee，Less，Browserify但使用等</li>
</ol>
<p>我甚至直接跳过了构建整个流程的过程，也跳过了测试如何编写。其实其中很多细节都可以拓展来讲，测试，模块化等，接下来博客也许会往这个方向去写。</p>
<p>（全文完）</p>
<style>img.middle{width: 65%;display: block;border: 1px solid #ccc;}</style>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="1-_前言">1. 前言</h2>
<p>HTML5在前几天终于成为了W3C推荐的标准，让Web开发者们非Web开发者们和不知道是什么但是看起来很厉害于是一起起哄的人高潮了一顿，普天同庆。</p>
<p>其实没什么好high的，在2008年HTML5就完成了draft。早在2011年W3C就设了一个2014年完成标准的milestone。我大一毛都没长齐的时候就听师兄们说：”你毕业的时候HTML5就会完成并成为标准啦啦啦。” W3C只是完成了它们的计划而已。而且，这几年人们早就都把HTML5、CSS3用得出神入化了。</p>
<p>不过随着HTML5、ES6这些东西成为标准，还有最近世界上聪明的头脑们在Web方面进行的先烈和先驱般的探索，层出不穷的新语言、新技术、新框架，原来混沌的世界逐渐被开辟出一片天地。原来杂乱无章的Web前端开发过程也叫嚷着要规范化、标准化。随着众神们的努力，我相信很快，我们写一次前端代码就可以完美地在除了IE以外的各个浏览器中运行（脑洞有点大）。</p>
<p>扯得有点远，其实上面说的内容和我要介绍的东西无关。本文会介绍我常用的一种前端开发工作流程，并且提供一个模板，有兴趣的同学可以修改成适合自己的。</p>
<h2 id="2-_前端自动化工作流简介">2. 前端自动化工作流简介</h2>
<p>每种项目都有自己特定的开发流程、工作流程。从需求分析、设计、编码、测试、发布，一个整个开发流程中，会根据不同的情况形成自己独特的步骤和流程。一个工作流的过程不是一开始就固定的，而是随着项目的深入而不断地改进，期间甚至会形成一些工具。例如当年大神们在Linux写C语言，觉得每次编译好多文件好麻烦，就发明了makefile。不同代码的管理好麻烦，然后就发明了git、SVN等等。</p>
<p>一个工作流程的好坏会影响你开发的效率、开发的流程程度，然后间接影响心情，打击编码积极性。所以我认为开发一个项目的时候，编码前把工作流程梳理清楚确定下来是一个非常重要的步骤。并且这个流程要在真实环境中不停的改进。</p>
<p>对于要负责页面结构和内容、外观、逻辑的前端来说，一个好的工作流至关重要。而且这里中没有银弹。要根据具体项目所使用的框架、应用场景来进行调整独特的工作流。</p>
<p>我会介绍一个我经常使用的前端工作流，这个工作流只是一个原始的流程，一般来说，我会根据不同项目的不同来在这个基础上进行调整，形成每个项目独特的流程。所以这里的重点是领会构建工作流的思路，然后学会举一反三。</p>
<p>一个前端自动化开发流程中，我觉得至少需要做到以下几点：</p>
<ol>
<li>良好的模块化</li>
<li>自动化编译</li>
<li>自动化测试</li>
<li>实时刷新页面</li>
<li>自动化打包、压缩发布</li>
</ol>
<p>能用机器的地方就不要自己动手，除了上述必备的几点，有时候要根据特定的情况编写一些Python、Nodejs、Shell脚本来避免重复的操作。好好呵护你的F5和稀疏的脑神经，男人要对自己好一点。</p>
]]>
    
    </summary>
    
      <category term="web" scheme="http://pinghackers.com/tags/web/"/>
    
      <category term="前端" scheme="http://pinghackers.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unix哲学与Node.js]]></title>
    <link href="http://pinghackers.com/2014/11/01/unix-and-nodejs/"/>
    <id>http://pinghackers.com/2014/11/01/unix-and-nodejs/</id>
    <published>2014-11-01T04:04:50.000Z</published>
    <updated>2014-11-16T15:54:47.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<p>翻译自：<a href="http://blog.izs.me/post/48281998870/unix-philosophy-and-node-js" target="_blank" rel="external">Unix Philosophy and Node.js</a>。</p>
<hr>
<p><strong>[译注]</strong></p>
<p>大一的时候玩过Linux，当时懵懵懂懂（现在也是），好多东西不知道是干diao用的，糊里糊涂地学了一堆命令；最后除了帮隔壁宿舍的后现代主义抠脚大师装系统的时候装X用一下以外基本没有发挥太大的用途。</p>
<p>后来断断续续使用Linux，也没有很深地钻研进去。最近捡回来看了一下，惊异地发现，原来一直以来那些编码中所用到的概念其实很多都源于Unix当中古老的设计。JS中的事件、Node.js中的Stream、多线程（进程）、管道、socket等等，都一一可以在这些古老的设计中找到源头。虽然没有非常深入了解到其中深奥的机制，但是带给我的感觉整个世界就像《三体》里面的三维生物在二维平面展开，很多细节都清晰明了。</p>
<p>在软件这个迭代更新迅速的领域，Unix不得不说是一个奇葩中的奇葩，自从设计完成以后以来基本上没有做过太多的修改，但是却持续地发光发热了几十年，支撑它的不仅仅是它精妙的设计，还有前辈们因为Unix而奠定的Unix哲学，影响了不仅仅是一个操作系统，而是几代Hackers的对程序的理解，对架构的设计。你几乎可以在那些最优秀的Hackers写的每一行代码中看到Unix哲学的身影。</p>
<p>本文的作者<a href="http://blog.izs.me" target="_blank" rel="external">isz</a>是<a href="https://github.com/npm/npm" target="_blank" rel="external">npm</a>（Node.js包管理器）的主要代码贡献者，在他的文章中，可以窥见Unix哲学对Node.js设计，文化所产生的影响。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/alice.jpg" alt="block"></p>
<p>以下是正文：</p>
<hr>
<p>在TxJS的另外一天，我做了一个演讲，提到了Unix哲学是Node.js的模式、主张、和文化很重要的一部分。像往常一样，在视频流出之前，我提前把展示用到的<a href="http://j.mp/node-patterns-pdf" target="_blank" rel="external">幻灯片</a>放网上。</p>
<p>出于某些原因，简短地提及“Unix哲学”引起了一些人的忿怒。当时我只有25分钟，但是我讲的每一页幻灯片都可以单出拿出来做一个演讲，所以我只好尽量地把精华抽出来讲。视频不能很好地还原当时的场景。但是我的目的是能够引起大家的讨论，所以如果它引起了一些批评，也许我的目标就达到了。毕竟，无知地唱高调只适合说教，我想我最好解释一下。</p>
<a id="more"></a>

<p>Eirc S. Raymond在他的<em><a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html" target="_blank" rel="external">The Art Of Unix Programming</a></em>收集了一些关于Unix哲学的最佳阐述。他详细讨论了17条特定的原则，但是我最喜欢的关于Unix哲学的阐述是Salus在他的<em>A Quarter Century of Unix</em>引用Doug McIlroy的简洁的陈述：</p>
<blockquote>
<p>这就是Unix的哲学：</p>
<p>写只做一件事并且把这件事做好的程序。</p>
<p>写能组合在一起运作的程序。</p>
<p>写能处理文本流的程序，因为文本流是通用的接口。</p>
</blockquote>
<p>McIlroy接下来稍微详细地给出了4点自己的陈述：</p>
<blockquote>
<p>(i) 每个程序只做好一件事情。当需要完成新的任务的时候，写一个新的程序而不是原有程序上添加新功能。</p>
<p>(ii) 让每一个程序的输出可以成为另外一个程序的输入，甚至是未知的程序的输入。不要在输入中混杂着无用的信息。避免严格按列排列二进制的输入格式。不要依赖交互式输入。</p>
<p>(iii) 在设计和编写软件，甚至是操作系统的时候，要尽快地尝试，最好是在几个星期之内就完成。要毫无顾虑地删掉笨拙的地方和重写它们。（译注：深有体会，绝B认同。）</p>
<p>(iv) 使用工具而不是蹩脚的编码来减轻编程任务，即使你知道你最后还是不得不自己来构建这些工具或者要放弃它们。</p>
</blockquote>
<p>在X桌面系统（译注：X是Linux下的桌面系统，没有它Linux就没有界面了）Mike Gancarz把Unix哲学总结成了9点：</p>
<blockquote>
<ol>
<li>精小就是优雅。</li>
<li>让每个程序只做好一件事情。</li>
<li>尽快地完成原型。</li>
<li>可移植性高于效率。</li>
<li>用纯文本来存放数据。</li>
<li>使用软件来加强你的优势。</li>
<li>使用Shell脚本来提高利用率和可移植性。</li>
<li>不要迷恋界面。</li>
<li>让每一个程序都成为过滤器。</li>
</ol>
</blockquote>
<p>最后一点和Ryan Dahl（译注：Node.js作者）经常说的“一切程序都是代理”（Every program is a proxy）产生了强烈的共鸣。前三点其实是<a href="http://substack.net/" target="_blank" rel="external">James Halliday</a>（译注：花名substack，疯了一样贡献了几百个Node.js模块，Node.js届无人不知的巨巨）的赖以生存的法则。</p>
<p>人们经常错误地迷失在Unix哲学的某些方面，而通常一叶障目不见森林。Unix哲学并不是一种特定的程序实现，或某种Unix操作系统或程序特有的东西。它并不是文件描述符，管道，套接字，或者信号量。这些误解就像是，除非一个人说<a href="http://en.wikipedia.org/wiki/Pali" target="_blank" rel="external">Pali语</a>，否则就不是佛教徒一样。</p>
<p>Unix哲学是软件开发的曙光，而不是软件中的一种特定技术开发。它是一种值得我们追求的理想境界，也许听起来有点讽刺：它是一种让指引我们要注重实用性而不是理想主义的理想境界。</p>
<p>在Node里面，人们之间分享和交互基本的构建的单元不是命令行中的二进制数据，而是通过<code>require</code>加载进来的模块。文本流<em>是</em>通用的接口，在Node.js里面其实就是JavaScript流对象，而不是标准输入输出中的管道。（标准输入输出的管道当然也在JavaScript流对象中体现出来了，因为它是我们通用的接口，我们还有其他选择吗？）</p>
<p>所以就从JavaScript的角度来说，我会说一下我是怎么表述Unix哲学的。哎～可惜我不是McIlroy，我也没有时间和能力去把它写得更精简，大家就将就一下吧：</p>
<blockquote>
<p>写只做好一件事的模块。写新的模块而不是增加旧的模块的复杂性。</p>
<p>写鼓励组合而不是鼓励扩展的模块。</p>
<p>写能够处理数据流的模块，因为它是通用的接口。</p>
<p>写对数据来源和去向都无知的模块。</p>
<p>写某块来解决你知道的问题，那么你就可以知道哪些问题你是不知道的。</p>
<p>写小的模块。迅速地迭代。无情地重构。勇敢地重写。</p>
<p>迅速地写模块来满足你的需求，写几个测试来合乎规范。避免臃肿的文档。为你fix掉的每个bug写测试。</p>
<p>能工作优于完美</p>
<p>功能专注优于功能丰富</p>
<p>兼容性优于纯粹性</p>
<p>简单优于任何东西</p>
</blockquote>
<p>Unix哲学是一种实用主义意识形态。是关于如何在写<em>好的软件</em>和写<em>任何软件</em>这两种需求中取得平衡。它是一套实用的建议，牺牲开发成本中的稳健性来获取更低的维护成本。</p>
<p>在现实世界当中，作为人类，我们在编写和调试程序的时候面临这一种相当不公平的约束，编码和调试的成本永远不可能降低到0。这种观念是有情景的，并且可以应用到所有的层次当中。我们都承认，我们没有聪明到写一次就知道如何把我们要写的软件写对，因为只有当我们把问题解决的时候我们才能完全理解问题。</p>
<p><strong>不是所有规则都是神圣不可侵犯的！</strong>事实上，在很多情景下面，这些规则都是有争议甚至有时候是完全相反的。即便这样，如果我们把让我们程序的单元保持精小，加以简单通用的接口，我们就可以把所有零散的部件组合成一个高品质的齿轮，那么在我们滚动的时候，可以轻松自在地把笨拙的部分换出去。</p>
<p>没有线索清晰地表明Unix哲学和软件分享文化有什么关系。但是，它无疑是来自于我们一直在其中讨论如何让我们的软件更加自由的社区。根据这些原则来开发的软件，会更加容易地被分享，重用，重改和维护。</p>
<p>（完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<p>翻译自：<a href="http://blog.izs.me/post/48281998870/unix-philosophy-and-node-js" target="_blank" rel="external">Unix Philosophy and Node.js</a>。</p>
<hr>
<p><strong>[译注]</strong></p>
<p>大一的时候玩过Linux，当时懵懵懂懂（现在也是），好多东西不知道是干diao用的，糊里糊涂地学了一堆命令；最后除了帮隔壁宿舍的后现代主义抠脚大师装系统的时候装X用一下以外基本没有发挥太大的用途。</p>
<p>后来断断续续使用Linux，也没有很深地钻研进去。最近捡回来看了一下，惊异地发现，原来一直以来那些编码中所用到的概念其实很多都源于Unix当中古老的设计。JS中的事件、Node.js中的Stream、多线程（进程）、管道、socket等等，都一一可以在这些古老的设计中找到源头。虽然没有非常深入了解到其中深奥的机制，但是带给我的感觉整个世界就像《三体》里面的三维生物在二维平面展开，很多细节都清晰明了。</p>
<p>在软件这个迭代更新迅速的领域，Unix不得不说是一个奇葩中的奇葩，自从设计完成以后以来基本上没有做过太多的修改，但是却持续地发光发热了几十年，支撑它的不仅仅是它精妙的设计，还有前辈们因为Unix而奠定的Unix哲学，影响了不仅仅是一个操作系统，而是几代Hackers的对程序的理解，对架构的设计。你几乎可以在那些最优秀的Hackers写的每一行代码中看到Unix哲学的身影。</p>
<p>本文的作者<a href="http://blog.izs.me" target="_blank" rel="external">isz</a>是<a href="https://github.com/npm/npm" target="_blank" rel="external">npm</a>（Node.js包管理器）的主要代码贡献者，在他的文章中，可以窥见Unix哲学对Node.js设计，文化所产生的影响。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/alice.jpg" alt="block"></p>
<p>以下是正文：</p>
<hr>
<p>在TxJS的另外一天，我做了一个演讲，提到了Unix哲学是Node.js的模式、主张、和文化很重要的一部分。像往常一样，在视频流出之前，我提前把展示用到的<a href="http://j.mp/node-patterns-pdf" target="_blank" rel="external">幻灯片</a>放网上。</p>
<p>出于某些原因，简短地提及“Unix哲学”引起了一些人的忿怒。当时我只有25分钟，但是我讲的每一页幻灯片都可以单出拿出来做一个演讲，所以我只好尽量地把精华抽出来讲。视频不能很好地还原当时的场景。但是我的目的是能够引起大家的讨论，所以如果它引起了一些批评，也许我的目标就达到了。毕竟，无知地唱高调只适合说教，我想我最好解释一下。</p>
]]>
    
    </summary>
    
      <category term="unix" scheme="http://pinghackers.com/tags/unix/"/>
    
      <category term="nodejs" scheme="http://pinghackers.com/tags/nodejs/"/>
    
      <category term="翻译" scheme="http://pinghackers.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>

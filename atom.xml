<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[PingHackers]]></title>
  <subtitle><![CDATA[高质量原创技术博文分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://pinghackers.com/"/>
  <updated>2014-12-11T11:12:10.210Z</updated>
  <id>http://pinghackers.com/</id>
  
  <author>
    <name><![CDATA[Livoras]]></name>
    <email><![CDATA[me@livoras.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python2 基本数据结构源码解析]]></title>
    <link href="http://pinghackers.com/2014/12/11/python-datatype-source-analysis/"/>
    <id>http://pinghackers.com/2014/12/11/python-datatype-source-analysis/</id>
    <published>2014-12-10T16:05:00.000Z</published>
    <updated>2014-12-11T11:11:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：吴文杰</p>
<p><strong>原文链接</strong>：<a href="http://pinghackers.com/2014/12/11/python-datatype-source-analysis/" target="_blank" rel="external">http://pinghackers.com/2014/12/11/python-datatype-source-analysis/</a></p>
<p><strong>本文同时也发布在</strong>：<a href="http://www.cnblogs.com/lhfcws/p/4156635.html" target="_blank" rel="external">http://www.cnblogs.com/lhfcws/p/4156635.html</a></p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h3 id="Contents">Contents</h3>
<ul>
<li>0x00. Preface</li>
<li>0x01. PyObject</li>
<li>0x01. PyIntObject</li>
<li>0x02. PyFloatObject</li>
<li>0x04. PyStringObject</li>
<li>0x05. PyListObject</li>
<li>0x06. PyDictObject</li>
<li>0x07. PyLongObject</li>
</ul>
<h3 id="0x00-_Preface">0x00. Preface</h3>
<p>一切皆对象，这是Python很重要的一个思想之一，虽然在语法解析上有些细节还是不够完全对象化，但在底层源码里，这个思想还是贯穿全系统的。（举个例子，<code>dir(2)</code> Python 可以识别出这是一个整型对象并打印出操作方法，但实际你却没办法 <code>2.real</code> 去调用，但 Ruby 却支持 <code>3.step(1, 2)</code>。）</p>
<p><strong>Version: 本文中所展示的源码及研究对象均来源自Python2最新版本（截止2014.12.01） Python 2.7.8。</strong></p>
<p><strong>Reference：《Python 源码剖析》 （陈儒），基于 Python2.5。在此基础上添补了一些内容和个人总结拓展，并结合Python 2.7.8的源码检查一遍，确认核心并未有较大变动。</strong></p>
<p><strong>本文假定读者至少能看懂C语言利用内存对齐技巧来模拟的结构体继承和多态，C语言的define和typedef的使用。</strong></p>
<h3 id="0x01-_PyObject">0x01. PyObject</h3>
<p>Python 源码里有个基本的随处可见的核心对象 PyObject，在源码里的地位和作用基本相当于 Java 里的所有类的超类 Object ，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* PyObject_HEAD defines the initial segment of every PyObject. */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PyObject_HEAD                   \</span></div><div class="line">    Py_ssize_t ob_refcnt;               \</div><div class="line">    <span class="keyword">struct</span> _typeobject *ob_type;</div><div class="line">    </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _object {</div><div class="line">    PyObject_HEAD</div><div class="line">} PyObject;</div></pre></td></tr></table></figure>



<p>（其实还有一行 _PyObject_HEAD_EXTRA 用于调试，但release版本中通常为空）</p>
<p>可见 PyObject 就两个成员，ob_refcnt 用于引用计数，ob_type用于指定当前 PyObject 的实际类型。引用计数是很多有自动垃圾回收机制的高级语言的GC的基础，这里不多赘述；_typeobject 结构体内容也比较复杂，暂时只需要知道用来描述对象类型即可。PyObject实际就这么多内容了。</p>
<p>Python里的对象主要分两种，定长对象和变长对象。<strong>这里强烈建议留意定长和变长的定义，网上有很多误导的错误解释。</strong>  </p>
<p>定长对象指对象在构造时便可知道长度的对象，包括int，float，bool，complex和dict等。其中比较特殊的是dict，dict的头部虽然是定长对象，但实际整个对象所占的大小也是会变的，不然新元素怎么办~dict采取的是类似数据库中可拓展哈希的方法进行增长，下文再细说。定长对象不需要特殊代码，PyObject 默认就是定长。</p>
<p>变长对象则在构造前是不知道长度的，包括long，str，list，tuple。long 这里和cpp里的长整型不一样，Python的long是用来支持大数运算的，上限取决于你的内存有多大，在你构造之前你怎么知道用户输入的那个数有多大，因此是个变长对象。变长对象的头部定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PyObject_VAR_HEAD               \</span></div><div class="line">    PyObject_HEAD                       \</div><div class="line">    Py_ssize_t ob_size;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">} PyVarObject;</div></pre></td></tr></table></figure>

<p>其实就是多了个 ob_size 来表示对象的大小。</p>
<a id="more"></a>

<h3 id="0x02-_PyIntObject">0x02. PyIntObject</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">    PyObject_HEAD</div><div class="line">    <span class="keyword">long</span> ob_ival;</div><div class="line">} PyIntObject;</div></pre></td></tr></table></figure>

<p>非常简单，Python的int就相当于C里的long，维护的时候大多数实际就是在维护long的值，除了类型转换的情况，比如相加相乘溢出的时候会自动转成PyLongObject。PyIntObject是不可变对象，即不可修改，只能创建删除读取。不可变对象的好处其实不用多说，共享并发时不需考虑锁冲突等开销，如今很多语言都在支持这种从函数式来的特性。</p>
<p>PyIntObject最特别的一点是区分大小整数，小整数全部事先创建好放在一个小整数对象池中，大整数则轮流共享一块内存。大小整数的判断是配置决定的，也就是说用户实际可以通过修改该值来进行调整。小整数对象池存在的原因是Python设计者认为像0 1 100 等这些小整数我们经常会几乎不可避免在各种地方用到，比如for、做flag值、计数器等，因此重复去创建销毁这些对象累积起来的开销实在没必要。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#ifndef NSMALLPOSINTS</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef NSMALLNEGINTS</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></div><div class="line"><span class="comment">/* References to small integers are saved in this array so that they</span></div><div class="line">   can be shared.</div><div class="line">   The integers that are saved are those in the range</div><div class="line">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div></pre></td></tr></table></figure>


<p>上述代码便是小整数池的声明，small_ints数组便是存放小整数的地方，小整数的范围默认是 [-5, 257) 。至于大整数，请看以下代码（留意我加的//注释）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Linklist member incapsulation</span></div><div class="line"><span class="keyword">struct</span> _intblock {</div><div class="line">    <span class="keyword">struct</span> _intblock *next;</div><div class="line">    PyIntObject objects[N_INTOBJECTS];</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _intblock PyIntBlock;</div><div class="line"></div><div class="line"><span class="keyword">static</span> PyIntBlock *block_list = NULL;</div><div class="line"><span class="keyword">static</span> PyIntObject *free_list = NULL;</div><div class="line"></div><div class="line"><span class="keyword">static</span> PyIntObject *</div><div class="line">fill_free_list(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    PyIntObject *p, *q;</div><div class="line">    <span class="comment">/* Python's object allocator isn't appropriate for large blocks. */</span></div><div class="line">    <span class="comment">// Initialize a PyIntBlock</span></div><div class="line">    p = (PyIntObject *) PyMem_MALLOC(<span class="keyword">sizeof</span>(PyIntBlock));</div><div class="line">    </div><div class="line">    <span class="comment">// Init failed due to not enough memory</span></div><div class="line">    <span class="keyword">if</span> (p == NULL)</div><div class="line">        <span class="keyword">return</span> (PyIntObject *) PyErr_NoMemory();</div><div class="line">        </div><div class="line">    <span class="comment">// Add p to the head of block_list</span></div><div class="line">    ((PyIntBlock *)p)-&gt;next = block_list;</div><div class="line">    <span class="comment">// Set block_list head to p</span></div><div class="line">    block_list = (PyIntBlock *)p;</div><div class="line">    </div><div class="line">    <span class="comment">/* Link the int objects together, from rear to front, then return</span></div><div class="line">       the address of the last int object in the block. */</div><div class="line">    <span class="comment">// use ob_type to link the objects aray</span></div><div class="line">    p = &((PyIntBlock *)p)-&gt;objects[<span class="number">0</span>];</div><div class="line">    q = p + N_INTOBJECTS;</div><div class="line">    <span class="keyword">while</span> (--q &gt; p)</div><div class="line">        Py_TYPE(q) = (<span class="keyword">struct</span> _typeobject *)(q-<span class="number">1</span>);</div><div class="line">    Py_TYPE(q) = NULL;</div><div class="line">    <span class="keyword">return</span> p + N_INTOBJECTS - <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>


<p>上面代码中可以看到有一个比较丑陋的地方是用说好要当做类型描述的ob_type来充当next指针。最后fill_free_list返回的结果其实就是传递给了free_list变量，这时候free_list指向了objects链表的头部（即数组的尾部）。block_list是负责维护实际的对象池，和free_list则负责维护block_list中空闲的对象。换句话说，只要block_list当前的objects内有空闲的对象，则free_list不会为NULL，必然会指向某个空闲的对象（一般是最近被释放的对象）；当free_list为NULL，说明目前没有空对象了，则要调用fill_free_list方法。</p>
<p>free_list维护的实际是所有空闲的block，假如没有销毁，free_list默认指向新申请的连续空闲block的头部，通过fill_free_list中构建好的链表关系可以轻易地（O(1)）找到下一个空闲block；当有之前使用的block被销毁的时候，python会将该block加到free_list头部并使之成为新的链表头部，该block的ob_type（此处充当next指针）自然也就改成了旧的free_list。因此销毁代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">int_dealloc(PyIntObject *v)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v)) {</div><div class="line">        Py_TYPE(v) = (<span class="keyword">struct</span> _typeobject *)free_list;</div><div class="line">        free_list = v;</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span></div><div class="line">        Py_TYPE(v)-&gt;tp_free((PyObject *)v);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">int_free(PyIntObject *v)</div><div class="line">{</div><div class="line">    Py_TYPE(v) = (<span class="keyword">struct</span> _typeobject *)free_list;</div><div class="line">    free_list = v;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="0x02-_PyFloatObject">0x02. PyFloatObject</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">    PyObject_HEAD</div><div class="line">    <span class="keyword">double</span> ob_fval;</div><div class="line">} PyFloatObject;</div></pre></td></tr></table></figure>

<p>和 PyIntObject 很类似，实际维护的是一个C里的double值。它的机制和PyIntObject的大整数机制也基本一致，但没有小整数池，因为浮点数毕竟没有小整数那么常用，也很难界定哪些浮点数是较常用的。基本fill_free_list函数和销毁等实现都差不多，就不再重复列举代码。</p>
<p>总之底层实现核心区别就是一个没有小整数池，另一个没有溢出类型转换。因此你即使输一个很大的小数，她也会丢弃部分数位或使用e表达方式使之适应成一个double类型。</p>
<h3 id="0x03-_PyStringObject">0x03. PyStringObject</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">    <span class="keyword">long</span> ob_shash;</div><div class="line">    <span class="keyword">int</span> ob_sstate;</div><div class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* Invariants:</span></div><div class="line">     *     ob_sval contains space for 'ob_size+1' elements.</div><div class="line">     *     ob_sval[ob_size] == 0.</div><div class="line">     *     ob_shash is the hash of the string or -1 if not computed yet.</div><div class="line">     *     ob_sstate != 0 iff the string object is in stringobject.c's</div><div class="line">     *       'interned' dictionary; in this case the two references</div><div class="line">     *       from 'interned' to this object are *not counted* in ob_refcnt.</div><div class="line">     */</div><div class="line">} PyStringObject;</div></pre></td></tr></table></figure>


<p>PyStringObject是个变长对象但是也是个不可变对象。字段解释如下：</p>
<ul>
<li>ob_shash : 长整型哈希值，就是字符串通过位运算算出来的哈希值，有兴趣的同学可以去了解字符串哈希相关知识。</li>
<li>ob_sstate : 实际是个enum值，用来判断当前字符传对象是否intern共享（intern机制下文会描述）。</li>
<li>ob_sval : 字符串实际内容存放处，字符串第一位的头指针；其中长度并不是C中的\0决定，而是由PyObject_VAR_HEAD 中的 ob_size决定的；但其同样必须满足 ob_sval[ob_size] == ‘\0’。</li>
</ul>
<p>Intern 是一个共享机制，对象是size &lt;= 1 的短字符串，主要是为了节省字符串所占的空间。比如我有N个对象的值都是”Python”，对象自然是需要N个，但其实没必要将”Python”也复制N个。以下是intern的核心函数代码（为方便阅读，省略去了一些检查代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">PyString_InternInPlace(PyObject **p)</div><div class="line">{</div><div class="line">    <span class="keyword">register</span> PyStringObject *s = (PyStringObject *)(*p);</div><div class="line">    PyObject *t;</div><div class="line">    </div><div class="line">    <span class="comment">// interned表（dict对象）不存在则新建</span></div><div class="line">    <span class="keyword">if</span> (interned == NULL) {</div><div class="line">        interned = PyDict_New();</div><div class="line">        <span class="keyword">if</span> (interned == NULL) {</div><div class="line">            PyErr_Clear(); <span class="comment">/* Don't leave an exception */</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 查看该字符串的内容是否已被interned</span></div><div class="line">    t = PyDict_GetItem(interned, (PyObject *)s);</div><div class="line">    <span class="comment">// 若已interned则修改其引用计数，并将p指向t</span></div><div class="line">    <span class="keyword">if</span> (t) {</div><div class="line">        Py_INCREF(t);</div><div class="line">        Py_DECREF(*p);</div><div class="line">        *p = t;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// intern操作，将字符串尝试存入interned表中</span></div><div class="line">    <span class="keyword">if</span> (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; <span class="number">0</span>) {</div><div class="line">        PyErr_Clear();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">/* The two references in interned are not counted by refcnt.</span></div><div class="line">        The string deallocator will take care of this */</div><div class="line">    Py_REFCNT(s) -= <span class="number">2</span>;</div><div class="line">    PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先，很容易看出，interned变量其实是一个<code>dict&lt;PyObject *, PyObject *&gt;</code>对象。dict会将key转换为PyStringObject* 并使用其ob_shash值来做哈希，上文虽然没有将计算ob_shash的函数string_hash展示出来，但大家也很容易猜到，ob_shash计算仅与字符串实际内容有关，和PyObject无关，因此同样字符串即使对象不同它们的哈希值也是一样的。</p>
<p>这里还有一个trick可能比较绕的是引用计数，尤其是后面<code>Py_REFCNT(s) -= 2</code>有些莫名其妙。先看if (t)那块代码，若找到已经被interned过，t是之前第一个interned同样字符串的对象，p是当前想要intern的对象，那么p的当前引用计数减一，而interned的t对象引用计数加一。再结合倒数三四行的作者注释，很容易明白如果PyStringObject被interned了，那么这个时候与intern有关的引用计数不看refcnt了，而是要结合intern去计算实际引用值。<code>Py_REFCNT(s) -= 2</code>的原因是在PyDict set操作中作为key和value会导致其引用加2，因为在其他地方使用该对象时依然要遵循普通的引用计数机制。</p>
<p>最后一行代码设置状态为 SSTATE_INTERNED_MORTAL ，实际被interned了的字符串基本都不会被自动GC。</p>
<p>另一个特性是字符缓冲池，这个和小整数缓冲池很类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> PyStringObject *characters[UCHAR_MAX + <span class="number">1</span>];</div><div class="line"></div><div class="line">PyObject *</div><div class="line">PyString_FromStringAndSize(<span class="keyword">const</span> <span class="keyword">char</span> *str, Py_ssize_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">register</span> PyStringObject *op;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> && str != NULL &&</div><div class="line">        (op = characters[*str & UCHAR_MAX]) != NULL)</div><div class="line">    {</div><div class="line">    <span class="preprocessor">#ifdef COUNT_ALLOCS</span></div><div class="line">        one_strings++;</div><div class="line">    <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        Py_INCREF(op);</div><div class="line">        <span class="keyword">return</span> (PyObject *)op;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></div><div class="line">    op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</div><div class="line">    <span class="keyword">if</span> (op == NULL)</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    PyObject_INIT_VAR(op, &PyString_Type, size);</div><div class="line">    op-&gt;ob_shash = -<span class="number">1</span>;</div><div class="line">    op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</div><div class="line">    <span class="keyword">if</span> (str != NULL)</div><div class="line">        Py_MEMCPY(op-&gt;ob_sval, str, size);</div><div class="line">    op-&gt;ob_sval[size] = <span class="string">'\0'</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/* share short strings */</span></div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</div><div class="line">        PyObject *t = (PyObject *)op;</div><div class="line">        PyString_InternInPlace(&t);</div><div class="line">        op = (PyStringObject *)t;</div><div class="line">        nullstring = op;</div><div class="line">        Py_INCREF(op);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span> && str != NULL) {</div><div class="line">        PyObject *t = (PyObject *)op;</div><div class="line">        PyString_InternInPlace(&t);</div><div class="line">        op = (PyStringObject *)t;</div><div class="line">        characters[*str & UCHAR_MAX] = op;</div><div class="line">        Py_INCREF(op);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> (PyObject *) op;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上是根据字符串内容和长度构建新字符串的函数，核心主要看 size == 1 的那两个if对应的块代码。第一个很明显是判断如果构建的新对象是已经被缓冲了的，那么直接获取缓冲池里的对象并引用计数加一即可。第二个就是在缓冲池中新建字符串的情况，逻辑也很简单，构建好了op对象，将其intern，设为对应位置的缓冲对象并引用计数加一防止被回收。</p>
<h3 id="0x04-_PyListObject">0x04. PyListObject</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">    PyObject **ob_item;</div><div class="line">    Py_ssize_t allocated;</div><div class="line">} PyListObject;</div></pre></td></tr></table></figure>

<p>对象本身也很简单：</p>
<ul>
<li>ob_item ：存放列表实际元素的地方</li>
<li>allocated ： 预先申请的长度大小</li>
<li>ob_size ：列表实际元素的个数或列表实际长度，即len(list)</li>
</ul>
<p>ob_size和allocated可以简单直接理解成C++ STL里的size和capacity的关系，毕竟每次删改都去调整申请内存太浪费，当ob_size即将大于allocated时对象会自动去申请新的内存并调整allocated值，也就是说 <code>0 &lt;= ob_size &lt;= allocated</code> 永远成立。</p>
<p>说起来其实PyListObject也有个缓冲池机制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Empty list reuse scheme to save calls to malloc and free */</span></div><div class="line"><span class="preprocessor">#ifndef PyList_MAXFREELIST</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PyList_MAXFREELIST 80</span></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"><span class="keyword">static</span> PyListObject *free_list[PyList_MAXFREELIST];</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> numfree = <span class="number">0</span>;</div></pre></td></tr></table></figure>

<p>可以看到，默认有个80大小的缓冲池数组。一开始缓冲池里是什么都没有的，每销毁一个PyListObject的时候才会往缓冲池里添加新对象用于之后的缓冲，参看 list_dealloc 函数。而创建PyListObject则会先看看缓冲池有无可用的对象（numfree &gt; 0），优先从缓冲池里取对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">list_dealloc(PyListObject *op)</div><div class="line">{</div><div class="line">    Py_ssize_t i;</div><div class="line">    PyObject_GC_UnTrack(op);</div><div class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</div><div class="line">    <span class="keyword">if</span> (op-&gt;ob_item != NULL) {</div><div class="line">        i = Py_SIZE(op);</div><div class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) {</div><div class="line">            Py_XDECREF(op-&gt;ob_item[i]);</div><div class="line">        }</div><div class="line">        PyMem_FREE(op-&gt;ob_item);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST && PyList_CheckExact(op))</div><div class="line">        free_list[numfree++] = op;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</div><div class="line">    Py_TRASHCAN_SAFE_END(op)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>列表的其他增删操作没有太多的难点，唯一的问题就是大家留意回 ob_item。ob_item是PyObject<em>*类型，也就是说其实类似数组，数组元素类型为 PyObject </em> 。那么问题来了，PyObject并没有next指针（回想PyIntObject中还拿ob_type临时充当next指针了），因此ob_item实际是一段连续的内存，而且不是静态一次申请的（我多次添加元素，它会不断申请内存并调整allocated值）。这里就有个问题了，我的list可能会元素很多，虽然在ob_item里存的每一项仅是一个指针类型，但会不会和别的内存冲突了呢？有allocated值和C语言内置的realloc()函数，请不用担心。list_resize函数出场：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">list_resize(PyListObject *self, Py_ssize_t newsize)</div><div class="line">{</div><div class="line">    PyObject **items;</div><div class="line">    size_t new_allocated;</div><div class="line">    Py_ssize_t allocated = self-&gt;allocated;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">// 如果 allocated &gt;= newsize &gt;= allocated/2，则不调整内存</span></div><div class="line">    <span class="keyword">if</span> (allocated &gt;= newsize && newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) {</div><div class="line">        assert(self-&gt;ob_item != NULL || newsize == <span class="number">0</span>);</div><div class="line">        Py_SIZE(self) = newsize;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* This over-allocates proportional to the list size, making room</span></div><div class="line">     * for additional growth.  The over-allocation is mild, but is</div><div class="line">     * enough to give linear-time amortized behavior over a long</div><div class="line">     * sequence of appends() in the presence of a poorly-performing</div><div class="line">     * system realloc().</div><div class="line">     * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</div><div class="line">     */</div><div class="line">    <span class="comment">// 内存申请增长策略，比传统可拓展哈希的直接乘2要温和得多 :)</span></div><div class="line">    new_allocated = (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* check for integer overflow */</span></div><div class="line">    <span class="keyword">if</span> (new_allocated &gt; PY_SIZE_MAX - newsize) {</div><div class="line">        PyErr_NoMemory();</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 算上原有的内存，此处计算出总共需要的内存</span></div><div class="line">        new_allocated += newsize;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</div><div class="line">        new_allocated = <span class="number">0</span>;</div><div class="line">        </div><div class="line">    items = self-&gt;ob_item;</div><div class="line">    <span class="keyword">if</span> (new_allocated &lt;= (PY_SIZE_MAX / <span class="keyword">sizeof</span>(PyObject *)))</div><div class="line">        PyMem_RESIZE(items, PyObject *, new_allocated);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        items = NULL;</div><div class="line">        </div><div class="line">    <span class="keyword">if</span> (items == NULL) {</div><div class="line">        PyErr_NoMemory();</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 内存调整成功！</span></div><div class="line">    self-&gt;ob_item = items;</div><div class="line">    Py_SIZE(self) = newsize;</div><div class="line">    self-&gt;allocated = new_allocated;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾名思义 list_resize 就是调整列表申请内存的大小，当不够大的时候会去将其调大，当 <code>allocated/2 &gt; newsize</code>的时候，不需要那么大了又可以将其收缩。我们可以看到有个PY_SIZE_MAX上限，那么PY_SIZE_MAX到底多大呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Largest possible value of size_t. </span></div><div class="line">   SIZE_MAX is part of C99, so it might be defined on some </div><div class="line">   platforms. If it is not defined, (size_t)-1 is a portable </div><div class="line">   definition for C89, due to the way signed-&gt;unsigned </div><div class="line">   conversion is defined. */</div><div class="line"><span class="preprocessor">#ifdef SIZE_MAX</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PY_SIZE_MAX SIZE_MAX</span></div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PY_SIZE_MAX ((size_t)-1)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div></pre></td></tr></table></figure>

<p>可见列表元素上限和你的机器位数有关 :) （size_t在64位机器为8字节，在32位机器为4字节）。其实这里存在着一个tradeoff，我们看到按照上述机制的话realloc()必然会被调用很多次。我们之前搞那么多缓冲池机制不就是为了避免malloc()这样的内存操作吗？现在居然毫不客气地反复调用更耗时的realloc()。但是如果不用realloc的话就要把ob_item拉成一个真正的链表，而链表不能随机访问，势必降低了很多查询方面的效率，同时众所周知很多修改也是基于查询的。因此Python设计者依然选择了连续内存的方式，接着就是通过经验和测试选择一个合适的内存增长策略。这里给我们使用者的一个很大的提醒就是，尽可能提前在构造list的时候先告诉Python去申请一个合适的长度，不要总是偷懒写个 l = [] 就算了。</p>
<p>而tuple不存在会改变长度的问题，因此不需要反复去检查和调用resize函数。所以我们经常会建议可以的话使用tuple便是这样的原因。</p>
<h3 id="0x05-_PyDictObject">0x05. PyDictObject</h3>
<p>先引入Python dict的哈希机制，Python采用的是开放地址法来解决冲突，即会多次使用一个探测函数f去探寻新的可用地址。因此实际上这就构成了一个探测地址链，[f0, f1, f2, f3 …]。当其中f1突然被删掉的话，后面的f2 f3很可能就会陷入不可查询状态，这是PyDictObject里会解决的一个问题。</p>
<p>（感觉PyDictObject的定义风格和之前的不太一样。。。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PyDict_MINSIZE 8</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">    Py_ssize_t me_hash;</div><div class="line">    PyObject *me_key;</div><div class="line">    PyObject *me_value;</div><div class="line">} PyDictEntry;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _dictobject PyDictObject;</div><div class="line"><span class="keyword">struct</span> _dictobject {</div><div class="line">    PyObject_HEAD</div><div class="line">    Py_ssize_t ma_fill;  <span class="comment">/* # Active + # Dummy */</span></div><div class="line">    Py_ssize_t ma_used;  <span class="comment">/* # Active */</span></div><div class="line"></div><div class="line">    Py_ssize_t ma_mask;</div><div class="line"></div><div class="line">    PyDictEntry *ma_table;</div><div class="line">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class="keyword">long</span> hash);</div><div class="line">    PyDictEntry ma_smalltable[PyDict_MINSIZE];</div><div class="line">};</div></pre></td></tr></table></figure>

<p>PyDictObject的定义终于没有之前那几个对象那么简单了，估计有同学带着疑问看到这里，为什么Dict是个定长对象？！这里暂先按下，先介绍PyDictEntry。PyDictEntry 顾名思义就是dict中的实际的一条Entry，包含一个key的哈希值和其K-V。它可以在三种状态之间转换：Active、Unused、Dummy。</p>
<ul>
<li>Unused： me_key == me_value == NULL</li>
<li>Active： me_key != NULL &amp;&amp; me_value != NULL</li>
<li>Dummy：  一个伪删除状态，Active态的Entry被删除后会被设为Dummy态，为了防止探测链的断裂而设置的一种机制。此时 me_key == dummy（一个特定对象），me_value == NULL。</li>
</ul>
<p>PyDictEntry的状态转换机制如下：</p>
<ul>
<li><code>Unused</code> —insert—&gt; <code>Active</code></li>
<li><code>Active</code> —delete—&gt; <code>Dummy</code></li>
<li><code>Dummy</code>  —insert—&gt; <code>Active</code></li>
</ul>
<p>此时介绍PyDictObject的成员就相对易懂了：</p>
<ul>
<li>ma_fill ：Active + Dummy 的PyDictEntry总个数，其实就是从创建开始至今曾经为或正在为Active的PyDictEntry个数。</li>
<li>ma_used ：当前Active的个数</li>
<li>ma_mask ：当前PyDictObject所拥有的entry的数量</li>
<li>ma_table：指向一片PyDictEntry的首元素，类似PyListObject中的ob_item</li>
<li>ma_smalltable ：当dict元素小于PyDict_MINSIZE的时候就使用该数组存放entry。</li>
<li>ma_lookup ：指向一个探测函数</li>
</ul>
<p>按照惯例，先来看看new函数（依然是省去了一些检查和track的代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> INIT_NONZERO_DICT_SLOTS(mp) do {                                \</span></div><div class="line">    (mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;                               \</div><div class="line">    (mp)-&gt;ma_mask = PyDict_MINSIZE - <span class="number">1</span>;                                 \</div><div class="line">} <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EMPTY_TO_MINSIZE(mp) do {                                       \</span></div><div class="line">    <span class="built_in">memset</span>((mp)-&gt;ma_smalltable, <span class="number">0</span>, <span class="keyword">sizeof</span>((mp)-&gt;ma_smalltable));        \</div><div class="line">    (mp)-&gt;ma_used = (mp)-&gt;ma_fill = <span class="number">0</span>;                                  \</div><div class="line">    INIT_NONZERO_DICT_SLOTS(mp);                                        \</div><div class="line">} <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line">PyObject *</div><div class="line">PyDict_New(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">register</span> PyDictObject *mp;</div><div class="line">    <span class="comment">// 构建dummy对象</span></div><div class="line">    <span class="keyword">if</span> (dummy == NULL) { <span class="comment">/* Auto-initialize dummy */</span></div><div class="line">        dummy = PyString_FromString(<span class="string">"&lt;dummy key&gt;"</span>);</div><div class="line">        <span class="keyword">if</span> (dummy == NULL)</div><div class="line">            <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// numfree和free_list是不是很熟悉？</span></div><div class="line">    <span class="keyword">if</span> (numfree) {</div><div class="line">        mp = free_list[--numfree];</div><div class="line">        </div><div class="line">        assert (mp != NULL);</div><div class="line">        assert (Py_TYPE(mp) == &PyDict_Type);</div><div class="line">        </div><div class="line">        _Py_NewReference((PyObject *)mp);</div><div class="line">        <span class="keyword">if</span> (mp-&gt;ma_fill) {</div><div class="line">            <span class="comment">// 清空之前对象的内容</span></div><div class="line">            EMPTY_TO_MINSIZE(mp);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">/* At least set ma_table and ma_mask; these are wrong</span></div><div class="line">                if an empty but presized dict is added to freelist */</div><div class="line">            <span class="comment">// 初始化</span></div><div class="line">            INIT_NONZERO_DICT_SLOTS(mp);</div><div class="line">        }</div><div class="line">        </div><div class="line">        assert (mp-&gt;ma_used == <span class="number">0</span>);</div><div class="line">        assert (mp-&gt;ma_table == mp-&gt;ma_smalltable);</div><div class="line">        assert (mp-&gt;ma_mask == PyDict_MINSIZE - <span class="number">1</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        mp = PyObject_GC_New(PyDictObject, &PyDict_Type);</div><div class="line">        <span class="keyword">if</span> (mp == NULL)</div><div class="line">            <span class="keyword">return</span> NULL;</div><div class="line">        EMPTY_TO_MINSIZE(mp);</div><div class="line">    }</div><div class="line">    </div><div class="line">    mp-&gt;ma_lookup = lookdict_string;</div><div class="line">    <span class="keyword">return</span> (PyObject *)mp;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>PyDictObject也有一个类似PyListObject中的缓冲池技术，默认值也是80，原理参看PyListObject一节，不赘述。</p>
<p>新建初始化一个PyDictObject做了什么事呢？首先拿对象，要么从缓冲池里拿并做一个clear操作（EMPTY_TO_MINSIZE），要么就从内存里新申请；然后init，可以看到init里ma_table指向了ma_smalltable，这里有个小数组机制，即size小于PyDict_MINSIZE（默认为8）时，数据是存放在ma_smalltable的，ma_table自然指向ma_smalltable；当大于PyDict_MINSIZE时，Python会将smalltable的内容拷贝到一段新的内存里并使ma_table指向新内存头部。相关重要函数是<br><code>static int dictresize(PyDictObject *mp, Py_ssize_t minused)</code>。</p>
<p>dictresize函数稍微有点长，此处不便贴太长代码 ，就说明一下。首先函数找到一个刚好大于二的幂值的newsize（最小为PyDict_MINSIZE），然后判断newsize如果为PyDict_MINSIZE，则使用ma_smalltable，将ma_table指向ma_smalltable；否则则在堆上申请新的大小为 newsize * sizeof(PyDictEntry) 的内存，并将ma_table指向该片内存。接着数据迁移，将active态的entry调用insertdict方法插入进dict中（由于内存要么是新申请的，要么是数组，所以可以默认此时的PyDictObject为空），将dummy态的减去引用计数并抛弃。可以看出dictresize也是一个大工程，但幸好的是每次增长是以二的幂增长，因此大部分时候调用resize的次数还是可接受的。</p>
<p>那么这时候也可以回答一开始的问题，PyDictObject是定长对象因为初始构建(<code>PyDict_New()</code>)的时候，我们知道dict长度一定是PyDict_MINSIZE，这符合定长对象的定义。至于<code>PyDict_NewPresized(Py_ssize_t minused)</code>该函数其实也只是个封装，先调用了new再resize，所以本质没有变。</p>
<p>其他主要的点就是插入、删除过程中调用到的ma_lookup指向的探测函数的使用，这里实际是哈希方面的算法内容，基本了解哈希的同学细心看代码都能明白，所以不赘述。</p>
<h3 id="0x06-_PyLongObject">0x06. PyLongObject</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// digit是个数值类型，根据不同可能为short，可能为uint32</span></div><div class="line"><span class="keyword">struct</span> _longobject {</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">    digit ob_digit[<span class="number">1</span>];</div><div class="line">};</div></pre></td></tr></table></figure>

<p>PyLongObject相对比较特殊，因为引入的比其他类型要晚。先看创建。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_LONG_DIGITS \</span></div><div class="line">((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/<span class="keyword">sizeof</span>(digit))</div><div class="line"></div><div class="line">PyLongObject *</div><div class="line">_PyLong_New(Py_ssize_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) </div><div class="line">    {</div><div class="line">        PyErr_SetString(PyExc_OverflowError,</div><div class="line">                        <span class="string">"too many digits in integer"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    <span class="comment">/* coverity[ampersand_in_size] */</span></div><div class="line">    <span class="comment">/* XXX(nnorwitz): PyObject_NEW_VAR / _PyObject_VAR_SIZE </span></div><div class="line">        need to detect overflow */</div><div class="line">    <span class="keyword">return</span> PyObject_NEW_VAR(PyLongObject, &PyLong_Type, size);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 该段函数不需要细读，扫一下就行 :)</span></div><div class="line">PyObject *</div><div class="line">PyLong_FromLong(<span class="keyword">long</span> ival)</div><div class="line">{</div><div class="line">    PyLongObject *v;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> abs_ival;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> t;  <span class="comment">/* unsigned so &gt;&gt; doesn't propagate sign bit */</span></div><div class="line">    <span class="keyword">int</span> ndigits = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> negative = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ival &lt; <span class="number">0</span>) {</div><div class="line">  </div><div class="line">        abs_ival = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(-<span class="number">1</span>-ival) + <span class="number">1</span>;</div><div class="line">        negative = <span class="number">1</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        abs_ival = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ival;</div><div class="line">    }</div><div class="line"></div><div class="line">   </div><div class="line">    t = abs_ival;</div><div class="line">    <span class="keyword">while</span> (t) {</div><div class="line">        ++ndigits;</div><div class="line">        t &gt;&gt;= PyLong_SHIFT;</div><div class="line">    }</div><div class="line">    v = _PyLong_New(ndigits);</div><div class="line">    <span class="keyword">if</span> (v != NULL) {</div><div class="line">        digit *p = v-&gt;ob_digit;</div><div class="line">        v-&gt;ob_size = negative ? -ndigits : ndigits;</div><div class="line">        t = abs_ival;</div><div class="line">        <span class="keyword">while</span> (t) {</div><div class="line">            *p++ = (digit)(t & PyLong_MASK);</div><div class="line">            t &gt;&gt;= PyLong_SHIFT;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> (PyObject *)v;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们上面讲过size_t是和机器相关的，也就是说long的上限其实是和机器相关的，大部分时候达不到那个值（比如8字节），所以一般实际和内存大小相关。然后随便看一下FromLong函数，这段函数不需要细读的原因是其实就是一段高精度的实现，数字实际都存储在ob_digit开始的一段连续内存中。这里因为PyLongObject是不可变对象，一开始便申请了固定大小内存，所以不需要像list那样去realloc，直接使用连续内存即可。其他操作（其实就是类似高精度的各种运算）和销毁都很简单，就不赘述。</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers |  Python2 基本数据结构源码解析 | 一切皆对象，这是Python很重要的一个思想之一，虽然在语法解析上有些细节还是不够完全对象化，但在底层源码里，这个思想还是贯穿全系统的。（举个例子，`dir(2)` Python 可以识别出这是一个整型对象并打印出操作方法，但实际你却没办法 `2.real` 去调用，但 Ruby 却支持 `3.step(1, 2)`。）]]>
    
    </summary>
    
      <category term="python" scheme="http://pinghackers.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CG学习之DOF景深算法]]></title>
    <link href="http://pinghackers.com/2014/12/05/cg-dof/"/>
    <id>http://pinghackers.com/2014/12/05/cg-dof/</id>
    <published>2014-12-05T14:27:39.000Z</published>
    <updated>2014-12-06T04:17:31.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>何为DOF</li>
<li>前置技能——Blur的实现</li>
<li>粗糙的DOF实现方法</li>
<li>较好的DOF实现方法</li>
</ul>
<h2 id="何为DOF">何为DOF</h2>
<p>DOF，全称叫做”Depth Of Field”，也就是景深效果，是CG中常用的效果。</p>
<p>举一个最简单的栗子：当你在看电影的时候，应该经常注意到镜头几乎从来都是聚焦到主角的脸上，比方说下面这张图（来源于陆小凤传奇之绣花大盗）：<br><a id="more"></a></p>
<p><img src="http://noahzuo-noah.stor.sinaapp.com/Image.png" alt="Focus-Blur之样例"></p>
<p>此时镜头的全部聚焦于张智霖的脸上了，一般人肯定也是聚精会神在这个帅比的脸上，但是细心的童鞋肯定会发现此时他身后的背景和镜头与他之间的景物此时被模糊了，这就是DOF效果。</p>
<p>总之，就是需要在渲染的时候展现深度信息，这就是DOF效果的目的。</p>
<h2 id="前置技能——Blur的实现">前置技能——Blur的实现</h2>
<p>Blur，又称为平滑、模糊化，也就是说把一张图变得比较模糊。在CG中，这通常是通过滤波器来实现的。滤波器这个名字听起来可能比较让人尿一裤子，实际上，也就是一张纹理，我们在对某个像素点进行采样的时候，不仅仅只取这个点的像素值，而是会考虑取它周围的像素点的一些权重的颜色值，如下图，我们对于这个坐标的像素点取了1/4的比例权重，而对于上下左右比较近的点，去了1/8的权重，对于左上、左下、右上、右下的点，取了1/16的权重，从而实现了平滑滤波。</p>
<p><img src="http://noahzuo-noah.stor.sinaapp.com/dof-BlurFilter-Image.png" alt="最简单的滤波器！"></p>
<p>当然，还有很多其他的滤波器可供选择，但是原理都是一样的。BTW，大三树莓班朝红阳教授的DIP课程简直是神课，看到好多师弟师妹的吐槽心里感觉挺不是滋味的……</p>
<p>知道了滤波器的原理那么实现起来就很简单了……以下是实现像素着色器的代码，采用的是HLSL的着色语言：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> sampleDist0;</div><div class="line">sampler RT;</div><div class="line"><span class="comment">// Simple blur filter</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> float2 samples[<span class="number">12</span>] = {</div><div class="line">   -<span class="number">0.326212</span>, -<span class="number">0.405805</span>,</div><div class="line">   -<span class="number">0.840144</span>, -<span class="number">0.073580</span>,</div><div class="line">   -<span class="number">0.695914</span>,  <span class="number">0.457137</span>,</div><div class="line">   -<span class="number">0.203345</span>,  <span class="number">0.620716</span>,</div><div class="line">    <span class="number">0.962340</span>, -<span class="number">0.194983</span>,</div><div class="line">    <span class="number">0.473434</span>, -<span class="number">0.480026</span>,</div><div class="line">    <span class="number">0.519456</span>,  <span class="number">0.767022</span>,</div><div class="line">    <span class="number">0.185461</span>, -<span class="number">0.893124</span>,</div><div class="line">    <span class="number">0.507431</span>,  <span class="number">0.064425</span>,</div><div class="line">    <span class="number">0.896420</span>,  <span class="number">0.412458</span>,</div><div class="line">   -<span class="number">0.321940</span>, -<span class="number">0.932615</span>,</div><div class="line">   -<span class="number">0.791559</span>, -<span class="number">0.597705</span>,</div><div class="line">};</div><div class="line"></div><div class="line">float4 main(float2 texCoord: TEXCOORD0) : COLOR {</div><div class="line">   float4 sum = tex2D(RT, texCoord);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++){</div><div class="line">      sum += tex2D(RT, texCoord + sampleDist0 * samples[i]);</div><div class="line">   }</div><div class="line">   <span class="keyword">return</span> sum / <span class="number">13</span>;</div><div class="line">}</div></pre></td></tr></table></figure>    

<p><em>markdown没有HLSL语法支持orz……</em></p>
<h2 id="粗糙的DOF实现方法">粗糙的DOF实现方法</h2>
<p>如果仅仅从展现效果来看，要实现DOF效果，那么只要在设定两个值，一个近平面一个远平面，在近平面中以内和远平面以外的像素我们采用Blur的像素点渲染，而在远平面和近平面之间的像素我们正常渲染。如果是这样的话那么我们就只需要进行深度的检测就可以了，不得不说是相当简单的方法：</p>
<p>在这里是使用了RenderMonkey进行实现，直接在Vertex Shader中将对应的Vertex的深度设为Far_Dist或者Near_Dist，然后进行深度模板的检测就可以了，Vertex Shader代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">float4x4 matViewProjection;</div><div class="line"><span class="keyword">float</span> fInverseViewportHeight;</div><div class="line"><span class="keyword">float</span> fInverseViewportWidth;</div><div class="line"><span class="keyword">float</span> Near_Dist;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> VS_OUTPUT</div><div class="line">{</div><div class="line">   float4 Position : POSITION ;</div><div class="line">   float2 Tex:TEXCOORD0 ;</div><div class="line">};</div><div class="line"></div><div class="line">VS_OUTPUT vs_main( float4 Position : POSITION )</div><div class="line">{</div><div class="line">   VS_OUTPUT Output;</div><div class="line">   Output.Position = float4(Position.xy , Near_Dist, <span class="number">1.0</span> );</div><div class="line">   Output.Tex .x = (Position.x + <span class="number">1.0</span> + fInverseViewportWidth) * <span class="number">0.5</span> ;</div><div class="line">   Output.Tex .y = (<span class="number">1.0</span> - Position.y + fInverseViewportHeight) * <span class="number">0.5</span>;</div><div class="line">  </div><div class="line">  </div><div class="line">   <span class="keyword">return</span>( Output );  </div><div class="line">}</div></pre></td></tr></table></figure>    

<p>效果如下：</p>
<p><img src="http://noahzuo-noah.stor.sinaapp.com/DOF-BlurFilter-Depth.png" alt="粗糙的DOF效果"></p>
<p>大致看起来效果还不错，但是这里存在着一个很严重的问题——且先把远处模糊和近处模糊的颜色分别用红绿颜色表示：</p>
<p><img src="http://noahzuo-noah.stor.sinaapp.com/DOF-BlurFilter-Depth-RedGreen.png" alt="粗糙的DOF效果之二"></p>
<p>大家估计能猜到问题是啥了吧，没错，这种的DOF实现会导致模糊处与正常渲染处的过渡非常尖锐，所以说这种方法虽然简单，但是局限性还是非常大的。当然改进的办法也不是没有，我们只要再次进行一次或者几次平滑滤波就可以把尖锐的波形给滤掉了。如果上过朝红阳教授的DIP课的童鞋会不会感到非常亲切呢哇哈哈哈哈……</p>
<h2 id="较好的DOF实现方法">较好的DOF实现方法</h2>
<p>在上面的DOF实现方法中，不足之处就在于<strong>深度值是跳跃的</strong>，从而导致Blur的效果在两个平面表现的非常尖锐。那么有啥办法能够让深度值表现的不那么跳跃呢？</p>
<p>其实很简单，我们在管线中另外声明一个值来储存这个点的深度不就够了咩？想到这一点后又不难联想到——颜色是使用RGBA四个分量来储存的，A分量还没用呢！那么我们只需要取得当前的视角变换矩阵，并且和这个点的Position分量进行矩阵乘法，就能获得它距离摄像机的距离了！</p>
<p>vs代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">float4x4 view_proj_matrix;</div><div class="line">float4x4 view_matrix;</div><div class="line"><span class="keyword">float</span> distanceScale;</div><div class="line"><span class="keyword">struct</span> VS_OUTPUT {</div><div class="line">   float4 Pos:      POSITION;</div><div class="line">   float2 texCoord: TEXCOORD0;</div><div class="line">   float3 normal:   TEXCOORD1;</div><div class="line">   float3 viewVec:  TEXCOORD2;</div><div class="line">};</div><div class="line"></div><div class="line">VS_OUTPUT main(float4 Pos: POSITION, float3 normal: NORMAL, float2 texCoord: TEXCOORD0){</div><div class="line">   VS_OUTPUT Out;</div><div class="line"></div><div class="line">   Out.Pos = mul(view_proj_matrix, Pos);</div><div class="line">   Out.texCoord = texCoord;</div><div class="line">   <span class="comment">// Eye-space lighting</span></div><div class="line">   Out.normal = mul(view_matrix, normal);</div><div class="line">   <span class="comment">// We multiply with distance scale in the vertex shader</span></div><div class="line">   <span class="comment">// instead of the fragment shader to improve performance.</span></div><div class="line">   Out.viewVec = -distanceScale * mul(view_matrix, Pos);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> Out;</div><div class="line">}</div></pre></td></tr></table></figure>    

<p>ps代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">float</span> Kd;</div><div class="line">    <span class="keyword">float</span> Ks;</div><div class="line">    float4 lightDir;</div><div class="line">    sampler Base;</div><div class="line">    float4 main(float2 texCoord: TEXCOORD0, float3 normal: TEXCOORD1, float3 viewVec: TEXCOORD2) : COLOR {</div><div class="line">       float3 base = tex2D(Base, texCoord);</div><div class="line">    </div><div class="line">       <span class="comment">// Basic lighting</span></div><div class="line">       <span class="keyword">float</span> diffuse = dot(lightDir, normal);</div><div class="line">       <span class="keyword">float</span> specular = <span class="built_in">pow</span>(saturate(dot(reflect(-normalize(viewVec), normal), lightDir)), <span class="number">16</span>);</div><div class="line">       float3 light = Kd * diffuse * base + Ks * specular;</div><div class="line">    </div><div class="line">       <span class="comment">// We'll use the distance to decide how much blur we want</span></div><div class="line">       <span class="keyword">float</span> dist = length(viewVec);</div><div class="line">    </div><div class="line">       <span class="keyword">return</span> float4(light, dist);</div><div class="line">}</div></pre></td></tr></table></figure><br>上面代码中的viewVec就是我所定义的这个顶点距离摄像机的向量，乘以一个distanceScale只是做一个范围的转变。<br><br>哦对了顺便说一句上面的代码涉及到一些光照模型的知识，本来想拉出来聊聊的但是嘉华说这些专业性太强了师妹估计看不懂所以提一下就可以了……话说看这些博客的师妹真的这么少么orz……<br><br>这是处理后的rendertarget图：<br><br><img src="http://noahzuo-noah.stor.sinaapp.com/DOF-BlurFilter-Alpha1.png" alt="renderTarget的纹理"><br><br>这是rendertarget的alpha通道图：<br><br><img src="http://noahzuo-noah.stor.sinaapp.com/DOF-BlurFilter-Alpha2.png" alt="renderTarget的alpha通道图"><br><br>经过这样一番处理可以看到顶点的深度信息已经写到renderTarget的alpha通道里了，并且alpha信息是连续的。<br><br>那么我们现在要做的就只是把深度信息转化为blur程度的信息，这还不简单咩？lerp函数伺候！<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> focus;</div><div class="line"><span class="keyword">float</span> range;</div><div class="line">sampler Blur1;</div><div class="line">sampler RT;</div><div class="line">float4 main(float2 texCoord: TEXCOORD0) : COLOR {</div><div class="line">   float4 sharp = tex2D(RT,   texCoord);</div><div class="line">   float4 blur  = tex2D(Blur1, texCoord);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> lerp(sharp, blur, saturate(range * <span class="built_in">abs</span>(focus - sharp.a)));</div><div class="line">}</div></pre></td></tr></table></figure>    

<p>效果如下：</p>
<p><img src="http://noahzuo-noah.stor.sinaapp.com/DOF-BlurFilter-Alpha-Result.png" alt="最终效果"></p>
<p>比起前一种方法的效果要好多啦！</p>
<p>（全文完）</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | CG学习之DOF景深算法 |DOF，全称叫做"Depth Of Field"，也就是景深效果，是CG中常用的效果，比如说Focus-Blur等效果都是基于DOF来实现。]]>
    
    </summary>
    
      <category term="CG" scheme="http://pinghackers.com/tags/CG/"/>
    
      <category term="Game" scheme="http://pinghackers.com/tags/Game/"/>
    
      <category term="Shader" scheme="http://pinghackers.com/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用git和github进行协同开发流程]]></title>
    <link href="http://pinghackers.com/2014/11/29/git-workflow/"/>
    <id>http://pinghackers.com/2014/11/29/git-workflow/</id>
    <published>2014-11-29T06:40:19.000Z</published>
    <updated>2014-11-29T07:08:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>原文链接</strong>：<a href="http://pinghackers.com/2014/11/29/git-workflow/" target="_blank" rel="external">http://pinghackers.com/2014/11/29/git-workflow/</a></p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<style>
    img {
        width: 80%!important;
    }
    img[alt="workflow"],
    img[alt="Overview"] {
        width: 60%!important;
    }
    img[alt="master & develop"],
    img[alt="origin"] {
        width: 40%!important;
    }
    img[alt="feature branch"] {
        width: 20%!important;
    }
</style>

<h2 id="目录">目录</h2>
<ul>
<li>前言</li>
<li>仓库（Repository）<ul>
<li>源仓库</li>
<li>开发者仓库</li>
</ul>
</li>
<li>分支（Branch）<ul>
<li>永久性分支</li>
<li>暂时性分支</li>
</ul>
</li>
<li>工作流（workflow）</li>
<li>总结</li>
<li>参考资料</li>
</ul>
<h2 id="前言">前言</h2>
<p>（本文假设各位已经对基本git的基本概念、操作有一定的理解，如无相关git知识，可以参考<a href="http://git-scm.com/book/zh/" target="_blank" rel="external">Pro Git</a>这本书进行相关的学习和练习）</p>
<p>很多项目开发都会采用git这一优秀的分布式版本管理工具进行项目版本管理，使用github开源平台作为代码仓库托管平台。由于git的使用非常灵活，在实践当中衍生了很多种不同的工作流程，不同的项目、不同的团队会有不同的协作方式。</p>
<p>本文将介绍一种前人已经在各种大小项目中经过千锤百炼总结出来的一种比较成功的git工作流，这种工作流已经被成功用于许多团队开发当中。掌握git，掌握这种工作流，对大家以后的学习、开发工作大有好处。</p>
<p>先上一张图吓大家一下：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/centr-decentr@2x.png" alt="workflow"></p>
<p>上面一张图展示了一种使用git进行项目协同开发的模式，接下来会进行详细介绍。</p>
<a id="more"></a>

<h2 id="仓库（Repository）">仓库（Repository）</h2>
<p>在项目的开始到结束，我们会有两种仓库。一种是源仓库（origin），一种是开发者仓库。上图中的每个矩形都表示一个仓库，正中间的是我们的源仓库，而其他围绕着源仓库的则是开发者仓库。</p>
<h3 id="源仓库">源仓库</h3>
<p>在项目的开始，项目的发起者构建起一个项目的最原始的仓库，我们把它称为<code>origin</code>，例如我们的PingHackers网站，<code>origin</code>就是这个<a href="https://github.com/PingHackers/blog" target="_blank" rel="external">PingHackers/blog</a>了。源仓库的有两个作用：</p>
<ol>
<li>汇总参与该项目的各个开发者的代码</li>
<li>存放趋于稳定和可发布的代码  </li>
</ol>
<p>源仓库应该是受保护的，开发者不应该直接对其进行开发工作。只有项目管理者（通常是项目发起人）能对其进行较高权限的操作。</p>
<h3 id="开发者仓库">开发者仓库</h3>
<p>上面说过，任何开发者都不会对源仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库的“复制”一份，作为自己日常开发的仓库。这个复制，也就是github上面的<code>fork</code>。</p>
<p>每个开发者所fork的仓库是完全独立的，互不干扰，甚至与源仓库都无关。每个开发者仓库相当于一个源仓库实体的影像，开发者在这个影像中进行编码，提交到自己的仓库中，这样就可以轻易地实现团队成员之间的并行开发工作。而开发工作完成以后，开发者可以向源仓库发送<code>pull request</code>，请求管理员把自己的代码合并到源仓库中，这样就实现了<strong>分布式开发工作</strong>，和最后的集中式的管理。</p>
<h2 id="分支（Branch）">分支（Branch）</h2>
<p>分支是git中非常重要的一个概念，也是git这一个工具中的大杀器，必杀技。在其他集中式版本管理工具（SVN/CVS）把分支定位为高级技巧，而在git中，分支操作则是每个开发人员日常工作流。利用git的分支，可以非常方便地进行开发和测试，如果使用git没有让你感到轻松和愉悦，那是因为你还没有学会使用分支。不把分支用出一点翔来，不要轻易跟别人说你用过git。</p>
<p>在文章开头的那张图中，每一个矩形内部纷繁的枝蔓便是git的分支模型。可以看出，每个开发者的仓库都有自己的分支路线，而这些分支路线会通过代码汇总映射到源仓库中去。</p>
<p>我们为git定下一种分支模型，在这种模型中，分支有两类，五种</p>
<ul>
<li>永久性分支<ul>
<li><code>master branch</code>：主分支</li>
<li><code>develop branch</code>：开发分支</li>
</ul>
</li>
<li>临时性分支<ul>
<li><code>feature branch</code>：功能分支</li>
<li><code>release branch</code>：预发布分支</li>
<li><code>hotfix branch</code>：bug修复分支</li>
</ul>
</li>
</ul>
<h3 id="永久性分支">永久性分支</h3>
<p>永久性分支是寿命无限的分支，存在于整个项目的开始、开发、迭代、终止过程中。永久性分支只有两个<code>master</code>和<code>develop</code>。</p>
<p><strong>master</strong>：主分支从项目一开始便存在，它用于存放经过测试，已经完全稳定代码；在项目开发以后的任何时刻当中，<code>master</code>存放的代码应该是可作为产品供用户使用的代码。所以，应该随时保持<code>master</code>仓库代码的清洁和稳定，确保入库之前是通过完全测试和代码reivew的。<code>master</code>分支是所有分支中最不活跃的，大概每个月或每两个月更新一次，每一次<code>master</code>更新的时候都应该用git打上<code>tag</code>，说明你的产品有新版本发布了。</p>
<p><strong>develop</strong>：开发分支，一开始从master分支中分离出来，用于开发者存放基本稳定代码。之前说过，每个开发者的仓库相当于源仓库的一个镜像，每个开发者自己的仓库上也有<code>master</code>和<code>develop</code>。开发者把功能做好以后，是存放到自己的<code>develop</code>中，当测试完以后，可以向管理者发起一个<code>pull request</code>，请求把自己仓库的<code>develop</code>分支合并到源仓库的<code>develop</code>中。</p>
<p>所有开发者开发好的功能会在源仓库的<code>develop</code>分支中进行汇总，当<code>develop</code>中的代码经过不断的测试，已经逐渐趋于稳定了，接近产品目标了。这时候，我们就可以把<code>develop</code>分支合并到<code>master</code>分支中，发布一个新版本。所以，一个产品不断完善和发布过程就正如下图：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/main-branches@2x.png" alt="master &amp; develop"></p>
<p>注意，任何人不应该向<code>master</code>直接进行无意义的合并、提交操作。正常情况下，<code>master</code>只应该接受<code>develop</code>的合并，也就是说，<code>master</code>所有代码更新应该源于合并<code>develop</code>的代码。</p>
<h3 id="暂时性分支">暂时性分支</h3>
<p>暂时性分支和永久性分支不同，暂时性分支在开发过程中是一定会被删除的。所有暂时性分支，一般源于<code>develop</code>，最终也一定会回归合并到<code>develop</code>。</p>
<p><strong>feature</strong>：功能性分支，是用于开发项目的功能的分支，是开发者主要战斗阵地。开发者在本地仓库从<code>develop</code>分支分出功能分支，在该分支上进行功能的开发，开发完成以后再合并到<code>develop</code>分支上，这时候功能性分支已经完成任务，可以删除。功能性分支的命名一般为<code>feature-*</code>，*为需要开发的功能的名称。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/fb@2x.png" alt="feature branch"></p>
<p>举一个例子，假设我是一名PingHackers网站的开发者，已经把源仓库fork了，并且clone到了本地。现在要开发PingHackers网站的“讨论”功能。我在本地仓库中可以这样做：</p>
<p>step 1: 切换到<code>develop</code>分支</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> git checkout develop</span></div></pre></td></tr></table></figure>

<p>step 2: 分出一个功能性分支</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> git checkout -b feature-discuss</span></div></pre></td></tr></table></figure>

<p>step 3: 在功能性分支上进行开发工作，多次commit，测试以后…</p>
<p>step 4: 把做好的功能合并到<code>develop</code>中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> git checkout develop</span></div><div class="line"><span class="input"><span class="prompt"></span></span></div><div class="line"># 回到develop分支</div><div class="line"></div><div class="line">&gt;&gt;&gt; git merge --no-ff feature-discuss</div><div class="line"><span class="input"><span class="prompt"># 把做好的功能合并到develop中</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git branch -d feature-discuss</div><div class="line"><span class="input"><span class="prompt"># 删除功能性分支</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git push origin develop</div><div class="line"><span class="comment"># 把develop提交到自己的远程仓库中</span></div></pre></td></tr></table></figure>

<p>这样，就完成一次功能的开发和提交。</p>
<p><strong>release</strong>：预发布分支，当产品即将发布的时候，要进行最后的调整和测试，这时候就可以分出一个预发布分支，进行最后的bug fix。测试完全以后，发布新版本，就可以把预发布分支删除。预发布分支一般命名为<code>release-*</code>。</p>
<p><strong>hotfix</strong>：修复bug分支，当产品已经发布了，突然出现了重大的bug。这时候就要新建一个<code>hotfix</code>分支，继续紧急的bug修复工作，当bug修复完以后，把该分支合并到<code>master</code>和<code>develop</code>以后，就可以把该分支删除。修复bug分支命名一般为<code>hotfix-*</code></p>
<p><code>release</code>和<code>hotfix</code>分支离我们还比较遥远。。就不详述，有兴趣的同学可以参考本文最后的参考资料进行学习。</p>
<h2 id="工作流（Workflow）">工作流（Workflow）</h2>
<p>啰嗦讲了这么多，概念永远是抽象的。对于新手来说，都喜欢一步一步的步骤傻瓜教程，接下来，我们就一步一步来操作上面所说的工作流程，大家感受一下：</p>
<h3 id="Step_1：源仓库的构建">Step 1：源仓库的构建</h3>
<p>这一步通常由项目发起人来操作，我们这里把管理员设为PingHackers，假设PingHackers已经为我们建立起了一个源仓库<a href="https://github.com/PingHackers/git-demo" target="_blank" rel="external">PingHackers/git-demo</a>，并且已经初始化了两个永久性分支<code>master</code>和<code>develop</code>，如图：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-branch.png" alt="origin"></p>
<h3 id="Step_2：开发者fork源仓库">Step 2：开发者fork源仓库</h3>
<p>源仓库建立以后，每个开发就可以去复制一份源仓库到自己的github账号中，然后作为自己开发所用的仓库。假设我是一个项目中的开发者，我就到<a href="https://github.com/PingHackers/git-demo" target="_blank" rel="external">PingHackers/git-demo</a>项目主页上去<code>fork</code>：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-fork.png" alt="fork"></p>
<p><code>fork</code>完以后，我就可以在我自己的仓库列表中看到一个和源仓库一模一样的复制品。这时就应该感叹，你以后要和它相依为命了：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-fork-origin.png" alt="fork-origin"></p>
<h3 id="Step_3：把自己开发者仓库clone到本地">Step 3：把自己开发者仓库clone到本地</h3>
<p>这一步应该不用教，git clone</p>
<h3 id="Step_4：构建功能分支进行开发">Step 4：构建功能分支进行开发</h3>
<p>进入仓库中，按照前面说所的构建功能分支的步骤，构建功能分支进行开发、合并，假设我现在要开发一个“讨论”功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> git checkout develop</span></div><div class="line"><span class="input"><span class="prompt"># 切换到`develop`分支</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git checkout -b feature-discuss</div><div class="line"><span class="input"><span class="prompt"># 分出一个功能性分支</span></span></div><div class="line"></div><div class="line">&gt;&gt; touch discuss.js</div><div class="line"><span class="input"><span class="prompt"># 假装discuss.js就是我们要开发的功能</span></span></div><div class="line"></div><div class="line">&gt;&gt; git add .</div><div class="line"><span class="input"><span class="prompt">&gt;&gt;</span> git commit -m <span class="string">'finish discuss feature'</span></span></div><div class="line"><span class="input"><span class="prompt"># 提交更改</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git checkout develop</div><div class="line"><span class="input"><span class="prompt"># 回到develop分支</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git merge --no-ff feature-discuss</div><div class="line"><span class="input"><span class="prompt"># 把做好的功能合并到develop中</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git branch -d feature-discuss</div><div class="line"><span class="input"><span class="prompt"># 删除功能性分支</span></span></div><div class="line"></div><div class="line">&gt;&gt;&gt; git push origin develop</div><div class="line"><span class="comment"># 把develop提交到自己的远程仓库中</span></div></pre></td></tr></table></figure>

<p>这时候，你上自己github的项目主页中<code>develop</code>分支中看看，已经有<code>discuss.js</code>这个文件了：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-push.png" alt="push"></p>
<h3 id="Step_5：向管理员提交pull_request">Step 5：向管理员提交pull request</h3>
<p>假设我完成了“讨论”功能（当然，你还可能对自己的<code>develop</code>进行了多次合并，完成了多个功能），经过测试以后，觉得没问题，就可以请求管理员把<strong>自己仓库的develop分支</strong>合并到<strong>源仓库的develop</strong>分支中，这就是传说中的<code>pull request</code>。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-pull-request.png" alt="pull-request"></p>
<p>点击上图的绿色按钮，开发者就可以就可以静静地等待管理员对你的提交的评审了。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-pull-request-origin.png" alt="pull-finished"></p>
<h3 id="Step_6_管理员测试、合并">Step 6 管理员测试、合并</h3>
<p>接下来就是管理员的操作了，作为管理员的PingHackers登陆github，便看到了我对源仓库发起的<code>pull request</code>。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/pull-request-origin.png" alt="pull-request-origin"></p>
<p>这时候PingHackers需要做的事情就是：</p>
<ol>
<li><strong>对我的代码进行review</strong>。github提供非常强大的代码review功能：<br><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-review.png" alt="reivew"></li>
<li><strong>在他的本地测试新建一个测试分支</strong>，测试我的代码：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; git checkout develop</div><div class="line"><span class="preprocessor"># 进入他本地的develop分支</span></div><div class="line"></div><div class="line">&gt;&gt; git checkout -b livoras-develop</div><div class="line"><span class="preprocessor"># 从develop分支中分出一个叫livoras-develop的测试分支测试我的代码</span></div><div class="line"></div><div class="line">&gt;&gt; git pull https:<span class="comment">//github.com/livoras/git-demo.git develop</span></div><div class="line"><span class="preprocessor"># 把我的代码pull到测试分支中，进行测试</span></div></pre></td></tr></table></figure>

<ol>
<li><strong>判断是否同意合并到源仓库的<code>develop</code>中</strong>，如果经过测试没问题，可以把我的代码合并到源仓库的<code>develop</code>中：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt;&gt;</span> git checkout develop</span></div><div class="line"><span class="input"><span class="prompt">&gt;&gt;</span> git merge --no-ff livoras-develop</span></div><div class="line"><span class="input"><span class="prompt">&gt;&gt;</span> git push origin develop</span></div></pre></td></tr></table></figure>

<p>注意，PingHakers一直在操作的仓库是源仓库。所以我们经过上面一系列操作以后，就可以在源仓库主页中看到：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/merge.png" alt="merge"></p>
<p>经过辗转曲折的路程，我们的<code>discuss.js</code>终于从我的开发仓库的功能分支到达了源仓库的<code>develop</code>分支中。以上，就是一个git &amp; github协同工作流的基本步骤。</p>
<h2 id="总结">总结</h2>
<p>git这一个工具博大精深，很难想象竟然有使用如此恶心而又如此灵活和优雅的工具存在；此又为一神器，大家还是多动手，多查资料，让git成为自己的一项基本技能，帮助自己处理各种项目团队协同工作的问题，成为一个高效的开发者、优秀的项目的管理者。送大家一张神图，好好领悟：</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/git/git-model@2x.png" alt="Overview"></p>
<p>最后给出一些参考资料，供参考学习。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">A Successful Git Branching Model</a></li>
<li><a href="https://sandofsky.com/blog/git-workflow.html" target="_blank" rel="external">Understanding the Git Workflow</a></li>
<li><a href="http://scottchacon.com/2011/08/31/github-flow.html" target="_blank" rel="external">Github flow</a></li>
<li><a href="http://git-scm.com/book/zh/" target="_blank" rel="external">Pro Git</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">Git分支管理策略</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | 使用git和github进行协同开发流程 | 本文将介绍一种前人已经在各种大小项目中经过千锤百炼总结出来的一种比较成功的git工作流，这种工作流已经被成功用于许多团队开发当中。掌握git，掌握这种工作流，对大家以后的学习、开发工作大有好处。]]>
    
    </summary>
    
      <category term="git" scheme="http://pinghackers.com/tags/git/"/>
    
      <category term="git workflow" scheme="http://pinghackers.com/tags/git-workflow/"/>
    
      <category term="github" scheme="http://pinghackers.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sinatra - 简洁的 Ruby 开发框架]]></title>
    <link href="http://pinghackers.com/2014/11/27/sinatra-introduction/"/>
    <id>http://pinghackers.com/2014/11/27/sinatra-introduction/</id>
    <published>2014-11-27T07:33:02.000Z</published>
    <updated>2014-11-27T09:00:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：吴泽秋</p>
<p><strong>原文链接</strong>：<a href="http://pinghackers.com/2014/11/27/sinatra-introduction/" target="_blank" rel="external">http://pinghackers.com/2014/11/27/sinatra-introduction/</a></p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<p>本文希望通过搭建简单的 Sinatra 应用作为栗子，来展示 Sinatra 这个轻量级框架的特点和开发模式。<br>毕竟不是官方文档，不能面面俱到，有心学习的同学可以通过文后附录的资料进一步研究，对文章中出现的问题也请读者们指正。</p>
<a id="more"></a>

<h2 id="Prerequisites_预备条件">Prerequisites 预备条件</h2>
<p>首先。你得。在机子上有 Ruby 环境。</p>
<p>如果是 Mac 用户请直接无视这一步。因为系统里已经有了。（不信 <code>ruby -v</code> 试试？）</p>
<p>如果是 Windows/Linux 用户，请在谷歌自行搜索教程，完成 <strong>Ruby开发环境的搭建</strong> 。当然如果有时间 <del>（还没有被毕业论文艹死）</del> 我也非常愿意来一发讲搭建开发环境的科普文。<br>（作为在 Windows/Linux/Mac 上都用过 Ruby 开发的人，表示如果要写，就写三个平台的，绝对业界良心）</p>
<h2 id="一个栗子的开始总是_Hello_world">一个栗子的开始总是 Hello world</h2>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># app.rb</span></div><div class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></div><div class="line"></div><div class="line">get <span class="string">'/hello'</span> <span class="keyword">do</span></div><div class="line">  <span class="string">'Hello world!'</span> <span class="comment"># return 'Hello world'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>接下来只需要在命令行里执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>gem install sinatra</div><div class="line"><span class="variable">$ </span>ruby app.rb</div></pre></td></tr></table></figure>

<p>看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">== Sinatra has taken the stage <span class="keyword">...</span></div><div class="line">&gt;&gt; Listening on <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">4567</span></div></pre></td></tr></table></figure>

<p>打开<code>http://localhost:4567/hello</code>就能看到浏览器上的 Hello world 了。</p>
<p><strong>就这么简单？确定不是在逗我么？</strong></p>
<p>是的。Sinatra 是基于 Ruby 语言的 <a href="http://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="external">DSL</a>，可以快速的创建一个 web 应用。</p>
<p>如果你使用过 Express，你会发现它和上述的 Sinatra 的例子的语法表述非常接近。<br>事实上，有 <a href="http://en.wikipedia.org/wiki/Sinatra_(software)#Frameworks_inspired_by_Sinatra" target="_blank" rel="external">大量的框架</a> 受到了 Sinatra 的影响。</p>
<p>但一个 naive 的 hello world 是拿不出手的，接下来我们会逐步的加入功能。</p>
<h3 id="添加路由">添加路由</h3>
<p>首先我们添加两个路由，分别接受 GET 和 POST 请求</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># app.rb</span></div><div class="line"><span class="comment"># ... 省略之前的代码</span></div><div class="line"></div><div class="line">get <span class="string">'/hello/:name'</span> <span class="keyword">do</span></div><div class="line">  <span class="string">"Hello <span class="subst">#{params[<span class="symbol">:name</span>]}</span>"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">post <span class="string">'/hello'</span> <span class="keyword">do</span></div><div class="line">  params[<span class="symbol">:name</span>] ||= <span class="string">"Nobody"</span> <span class="comment"># 如果post的数据中没有name，则设为 "Nobody"</span></div><div class="line">  <span class="string">"Hello <span class="subst">#{params[<span class="symbol">:name</span>]}</span>"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>对应的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">GET /hello/Bob</span> =&gt; <span class="string">"Hello Bob"</span></div><div class="line"><span class="constant">POST /hello</span> =&gt; <span class="string">"Hello Nobody"</span></div><div class="line"><span class="constant">POST /hello name</span>=Allen <span class="string">"Hello Allen"</span></div></pre></td></tr></table></figure>

<p>顺带提一句，你们是如何来测试非 GET 的接口呢？有两个常用的方法：</p>
<ol>
<li><p>在命令行下使用 curl：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">curl</span> <span class="url">http://localhost:4567/hello</span> <span class="comment"># 默认使用GET请求</span></div><div class="line">curl -X POST <span class="url">http://localhost:4567/hello</span> -d name=Allen <span class="comment"># 指定POST请求，带有数据 name=Allen，默认使用 application/x-www-form-urlencoded 格式</span></div><div class="line">curl -X POST <span class="url">http://localhost:4567/hello</span> -d name=Allen gender=male <span class="comment"># 多个数据的POST请求</span></div></pre></td></tr></table></figure>

<p>curl 是一个很方便的工具，在 linux 和 Mac OS 下都很容易可以得到，但在我们需要复杂的 POST 数据请求，或者是 JSON 请求时，curl 就会显得很麻烦。<br>以下推荐一个很好用的 Chrome App:</p>
</li>
<li>Advanced Rest Client<br>具体安装就不说了，请自行谷歌。只上图，不说话：<br><img src="/imgs/advanced-rest-client.png" alt="Advanced Rest Client"><br>用了之后，感觉自己萌萌哒。</li>
</ol>
<p>关于路由，再补充几点：</p>
<ol>
<li>和 Express 一样，路由按照被定义的顺序进行匹配——第一个与请求匹配的路由会被调用。在路由和请求不匹配时，请求会被丢给下一个路由去匹配。<br>最后没有匹配到任何路由的请求，会抛出异常并被 Sinatra 捕获，返回一个默认的 404 页面。</li>
<li>路由代码块的返回值（即最后一个表达式的值）决定了返回给 HTTP 客户端的响应体。大多数情况下是一个字符串，但也可以返回任何的对象。</li>
<li>路由的范式（即上文例子中的 <code>/hello</code>，<code>/hello/:name</code> 等）可以包含通配符参数，也可以使用正则表达式，这一点也和 Express 相同。</li>
<li>路由可以包括匹配条件，如 user agent；可以指定自定义的条件；可以指定返回的内容类型(html/rss/atom/xml)</li>
<li>在路由代码块中你可以用 <code>halt</code> 将请求挂起，也可以 <code>pass</code> 放弃处理请求，丢给后面的路由（和 Express 的 middleware 的 <code>next</code> 一样）；<br>还可以用 <code>redirect</code> 跳转到其他 url 上。</li>
</ol>
<p>更多关于路由的用法，请参考官方文档的<a href="https://github.com/sinatra/sinatra/blob/master/README.zh.md#%E8%B7%AF%E7%94%B1route" target="_blank" rel="external">路由</a>一节。</p>
<h3 id="添加首页模板">添加首页模板</h3>
<p>虽然通常我自己只用 Sinatra 来做小型的 API 服务，但实际上 Sinatra 也是可以通过模板来返回 view 页面的。以下应用 slim 模板，给应用加一个首页：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># app.rb</span></div><div class="line"><span class="comment"># 省略前面代码...</span></div><div class="line"></div><div class="line"><span class="keyword">require</span> <span class="string">'slim'</span></div><div class="line">get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">  slim <span class="symbol">:<span class="string">"home/index"</span></span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>在 Sinatra 中，模板文件默认是放置在 <code>views/</code> 文件夹下的。由于我们渲染的模板文件的路径是 <code>home/index</code>，所以模板文件为 <code>views/home/index.slim</code>：</p>
<figure class="highlight slim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">h1 Homepage</div><div class="line">p This <span class="keyword">is</span> the homepage. <span class="keyword">Let</span><span class="comment">'s Rock!</span></div></pre></td></tr></table></figure>

<p>在浏览器中访问 <code>http://localhost:4567/</code> 就可以看到刚刚完成的模板文件渲染的 html 页面。<br>但作为一个网站，通常我们需要有一个固定的公用布局。在 Sinatra 中，如果存在名为 “layout” 的模板，该模板会被默认使用。</p>
<p>我们希望网站的布局如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/------------------------------\</div><div class="line"><span class="string">|           header             |</span></div><div class="line"><span class="string">|------------------------------|</span></div><div class="line"><span class="string">|         |                    |</span></div><div class="line"><span class="string">|         |                    |</span></div><div class="line"><span class="string">| sidebar |    main content    |</span></div><div class="line"><span class="string">|         |                    |</span></div><div class="line"><span class="string">|         |                    |</span></div><div class="line"><span class="string">|------------------------------|</span></div><div class="line"><span class="string">|           footer             |</span></div><div class="line">\------------------------------/</div></pre></td></tr></table></figure>

<p>以下是 <code>views/layout.slim</code>：</p>
<figure class="highlight slim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">doctype html</div><div class="line">html</div><div class="line">  head</div><div class="line">    <span class="variable">title =</span> @title || <span class="string">"Sinatra Demo"</span></div><div class="line">  body</div><div class="line">    <span class="variable">header</span></div><div class="line">      = @title || <span class="string">"Sinatra Demo"</span></div><div class="line">    main</div><div class="line">      aside</div><div class="line">        ul</div><div class="line">          li</div><div class="line">            a <span class="variable">href=</span><span class="string">"/about"</span> =<span class="string">"about"</span></div><div class="line">      <span class="variable">section</span></div><div class="line">        == yield</div><div class="line">    footer</div></pre></td></tr></table></figure>

<p>这时刷新页面，发现首页的确出现了模板生成的 html 页面。需要解释的是 <code>views/layout.slim</code>  中的第4行，出现了一个 <code>@</code> 开头的变量 <code>@title</code>。<br>这个变量可以在路由中定义， 且不同的路由中可以对 <code>@title</code> 赋不同的值。</p>
<p>现在模板已经完成了，但从浏览器打开观看的效果很一般，需要添加一些样式，如果可能的话还需要添加一点 js。</p>
<h3 id="添加_assets">添加 assets</h3>
<p>在 Sinatra 中，静态文件是从 <code>./public_folder</code> 目录提供服务，可以通过设置 <code>:public_folder</code> 选项来指定一个不同的位置：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># app.rb</span></div><div class="line"><span class="comment"># 省略前面内容...</span></div><div class="line"></div><div class="line">set <span class="symbol">:public_folder</span>, <span class="constant">File</span>.dirname(__FILE_<span class="number">_</span>) + <span class="string">'/static'</span></div><div class="line"></div><div class="line"><span class="comment"># 省略路由...</span></div></pre></td></tr></table></figure>

<p>然后在 <code>views/layout.slim</code> 中加入一行，引用 CSS 文件：</p>
<figure class="highlight slim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">...</span> <span class="comment"># 省略</span></div><div class="line">   head</div><div class="line">     title = @title || <span class="string">"Sinatra Demo"</span></div><div class="line">     link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/css/style.css"</span> <span class="comment"># 添加 CSS</span></div><div class="line">   <span class="keyword">...</span> <span class="comment"># 省略</span></div></pre></td></tr></table></figure>

<p>最后新建 <code>static/css/sytle.css</code> 文件如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">header</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">100px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"><span class="tag">main</span> <span class="tag">aside</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">15%</span></span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"><span class="tag">main</span> <span class="tag">section</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">15%</span></span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"><span class="tag">footer</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">50px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<p>DONE. =&gt; 虽然有点丑，但意思表达出来就可以了。</p>
<p>插播一个问题。如果读者照着本文的流程做的话，会发现修改了 <code>app.rb</code> 之后的刷新有时会没有效果。解决的方法是将原来的 sinatra 应用关掉，重新开一次就可以了。<br>（话外音：这不科学啊老湿！艾伦：没错，其实有一个很好的解决方法，不过要留到以后再讲…）</p>
<h3 id="数据-持久化-ORM：DIY">数据-持久化-ORM：DIY</h3>
<p>好了，路由有了，页面也有了，接下来就是数据了，如何储存数据呢？使用过 Rails 的同学深谙 <a href="http://zh.wikipedia.org/zh/MVC" target="_blank" rel="external">MVC</a> 之道，<br>会觉得 Model 是和 Controller, View 结合甚好的一部分，如果是默认使用关系型数据库的童鞋，甚至不需要去管 sql ，<br>通过 Rails 赋予的 generator 也可以很舒服的建起一个 Model 来。</p>
<p>但这就是 Sinatra 的一大特色：选用什么数据库，和什么 ORM，是开发者自己要关心的事情，再也没有 Rails 这样的全职管家来 take care of it.<br>甚至连加载 Model 文件的路径，也需要自己设定，并不遵循任何的 convention. 在本例中，我采用 MongoDB 作为数据库，<br>于是我选用 Mongoid 来作为对接数据库的 <a href="http://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84" target="_blank" rel="external">ORM</a> 工具。</p>
<p>具体的代码是这样的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt"># models.rb</span></span></div><div class="line"># 由于整个应用就只有一个 Model，所以把代码集中到这里</div><div class="line"># 事实上，开发者可以按照自己的风格，建立 models/ 文件夹，再将各个 Model 独立成文件放在目录下</div><div class="line"></div><div class="line">class Todo</div><div class="line">  include Mongoid::Document</div><div class="line"></div><div class="line">  field :title, type: String</div><div class="line">  field :date, type: Date, default: Time.now</div><div class="line">  field :permalink, type: String, default: -&gt; { make_permalink }</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> </span>make_permalink</div><div class="line">    title.downcase.gsub(<span class="regexp">/\W/</span>, <span class="string">'-'</span>).squeeze(<span class="string">'-'</span>).chomp(<span class="string">'-'</span>) <span class="keyword">if</span> title</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>上述例子里的 Ruby 语法有点多，要完整解释有点麻烦。<br>看不懂的读者们（或者对 Mongoid 不了解的）可以先跳过，只要明白这个文件定义了 <code>Todo</code> Model就可以了。</p>
<p>接下来就要在主文件 <code>app.rb</code> 里引用 Model，然后在路由里操作之：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># app.rb</span></div><div class="line"><span class="comment"># 省略大量内容..</span></div><div class="line"></div><div class="line"><span class="keyword">require</span> <span class="string">'./models'</span></div><div class="line"></div><div class="line">get <span class="string">'/todos'</span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@todos</span> = <span class="constant">Todo</span>.all</div><div class="line">  <span class="variable">@title</span> = <span class="string">"Sinatra Demo || Todos"</span></div><div class="line">  slim <span class="symbol">:<span class="string">"/todos/index"</span></span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>最后是来一个模板 <code>views/todos/index.slim</code></p>
<figure class="highlight slim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">h1 Todos</div><div class="line">-<span class="ruby"> <span class="keyword">if</span> <span class="variable">@totos</span>.any?</span></div><div class="line">  ul.pages</div><div class="line">  -<span class="ruby"> <span class="variable">@todos</span>.each <span class="keyword">do</span> |todo|</span></div><div class="line">    li</div><div class="line">      a href="/#{<span class="ruby">url_for todo}</span>" =todo.title</div><div class="line">-<span class="ruby"> <span class="keyword">else</span></span></div><div class="line">  p No todos! Yeah!</div></pre></td></tr></table></figure>

<p>当然，为了完成这个 TODOLIST 的应用，你还需要写 create, delete, edit, … 这里就不赘述了</p>
<h2 id="Why_the_fuck_?">Why the fuck ?</h2>
<p>至此为止，一个大致的应用初具雏形。读者们可以在此基础上继续发挥（主要是添加增删改的路由，修改样式）来完成这个应用。</p>
<p>当然，你会发现这样做是一件很操蛋的事情—— Rails 早就做了，而且在构建 <strong>传统的增删查改</strong> 的业务上完爆 Sinatra（以及其他各类框架），<br>那 Sinatra 的意义何在呢？</p>
<p>就在于当你需要做一些非传统应用（如 API 服务，后台服务，甚至微信公众号时）可以很快的上手，不需要用 Rails 如此庞大的工具。这是 Sinatra 的应用场景。<br>举个不恰当的例子是：Rails 好比一辆重型坦克，很安全，功能很齐备；而 Sinatra 就像辆小单车一样简陋但好骑。问题只是在于当你希望小单车有诸多功能时，<br>你需要给它加上大量的组件，还是自己装上去的。说白了就是应用场景不同嘛。<del>哪来那么多废话</del></p>
<p>通常来说，在对 Rails 开发有一定了解之后再来学习 Sinatra 会比较好，<br>毕竟 Rails 的开发能够让开发者对构建 web 应用所需要的各个方面有一个全面的了解；<br>而且开发 Sinatra 需要的 Ruby 知识也更多，对于开发者个人能力的要求也更高——毕竟 Rails 的全面性和安全性是经过了社区的检验的，<br>单个开发者通过 Sinatra 写出的功能类似的应用未必能够考虑周全。</p>
<p>即使对于我本人来说，一开始学习 Sinatra 的目的也仅仅是为了学习而已。</p>
<h2 id="变成”大”应用：extensions_&amp;_Padrino">变成”大”应用：extensions &amp; Padrino</h2>
<p>这是之后可能会讲的一个内容。如何控制自己的应用？如何让应用变得模块化？<br>有没有既能享受 Sinatra 的灵便，但功能上又相对完备（比如能够对接数据库）的框架呢？</p>
<p>前两个问题可以通过 Sinatra 扩展解决；最后一个问题的答案是 Padrino —— 它本身就是汇集了多个 Sinatra 扩展的一个框架。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://github.com/sinatra/sinatra/blob/master/README.zh.md" target="_blank" rel="external">Sinatra 中文文档</a></li>
<li><a href="http://www.sinatrarb.com/" target="_blank" rel="external">Sinatra 官网</a></li>
<li><a href="https://ruby-china.org/topics/18292" target="_blank" rel="external">简单介绍Sinatra</a></li>
<li>【深度】<a href="https://ruby-china.org/topics/7921" target="_blank" rel="external">How Sinatra Works</a> by Hooopo</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | Sinatra - 简洁的 Ruby 开发框架 | 用惯了重型武器 Ruby on Rails，来看看轻量级框架 Sinatra 的特性和使用场景。]]>
    
    </summary>
    
      <category term="Ruby" scheme="http://pinghackers.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Erlang error handling]]></title>
    <link href="http://pinghackers.com/2014/11/25/erlang-error-handling/"/>
    <id>http://pinghackers.com/2014/11/25/erlang-error-handling/</id>
    <published>2014-11-25T13:47:36.000Z</published>
    <updated>2014-11-27T01:52:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：吴文杰</p>
<p><strong>原文链接</strong>：<a href="http://pinghackers.com/2014/11/25/erlang-error-handling/" target="_blank" rel="external">http://pinghackers.com/2014/11/25/erlang-error-handling/</a></p>
<p><strong>本文同时也发布在</strong>：<a href="http://www.cnblogs.com/lhfcws/p/4120965.html" target="_blank" rel="external">http://www.cnblogs.com/lhfcws/p/4120965.html</a></p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="Contents">Contents</h2>
<ol>
<li>Preface</li>
<li>try-catch</li>
<li>Process link</li>
<li>Erlang-way error handling</li>
<li>OTP supervisor tree</li>
<li>Restart process</li>
</ol>
<hr>
<h3 id="0-_Preface">0. Preface</h3>
<p>说到容错处理，大概大家都会想到 <code>try-catch</code> 类结构，对于绝大多数传统语言来说，确实是这样。但是对于Erlang来说，容错处理是其一个核心特性，真正涉及到的是整个系统的设计，与 <code>try-catch</code> 无关；其核心是Erlang进程本身的特性以及进程链接。</p>
<h3 id="1-_try-catch">1. try-catch</h3>
<blockquote>
<p>本节纯粹为科普</p>
</blockquote>
<p>不管怎么说，还是先介绍以下Erlang的 try-catch 结构（但请留意，try-catch 只作为引入，此小节以后的章节才是本文核心）。</p>
<p>Erlang 有三种错误类型：</p>
<ul>
<li>error: 运行时异常，比如零除错误、匹配错误等。一旦Error使某个进程崩溃，Erlang错误日志管理器会进行记录。</li>
<li>exit: 进程停止异常，Exit会在迫使进程崩溃的同时将进程退出的原因告诉其他进程，一般不建议对Exit作捕获。同时Exit也可在进程正常终止时使用。Erlang错误日志管理器不会接收到Exit的异常汇报。</li>
<li>throw: 和Java的Throwable较类似，大多用于用户自己throw出异常到上层函数。如果没有catch的话就会变成原因为nocatch的error，迫使进程停止并记录异常。这里有个trap，如果你用了尾递归优化的函数，throw后是只有一层stack的。</li>
</ul>
<p>关于尾递归的 throw，建议测试以下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">tail_throw</span><span class="params">(<span class="variable">I</span>)</span> -&gt;</span></div><div class="line">  if</div><div class="line">    <span class="variable">I</span> =&lt; <span class="number">0</span> -&gt;</div><div class="line">   	  <span class="function_name">throw</span>(<span class="function_name">erlang:get_stacktrace</span>());</div><div class="line">    <span class="variable">I</span> &gt; <span class="number">0</span> -&gt;</div><div class="line">   	  <span class="function_name">io:format</span>(<span class="string">"tail~n"</span>),</div><div class="line">      <span class="function_name">tail_throw</span>(<span class="variable">I</span> - <span class="number">1</span>)</div><div class="line">   	  ,<span class="function_name">io:write</span>(<span class="string">"~n"</span>)   <span class="comment">% try delete this line to see the differences</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">.</div></pre></td></tr></table></figure>    

<a id="more"></a>

<h4 id="try_catch">try_catch</h4>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">	do_stuff()</div><div class="line"><span class="keyword">catch</span></div><div class="line">	throw: <span class="variable">Other</span> -&gt; <span class="tuple">{get_throw, <span class="variable">Other</span>}</span>;</div><div class="line">	error: <span class="variable">Reason</span> -&gt; <span class="tuple">{get_error, <span class="variable">Reason</span>}</span>;</div><div class="line">	exit: <span class="variable">Reason</span> -&gt; <span class="tuple">{get_exit, <span class="variable">Reason</span>}</span></div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>    

<h4 id="try_of_catch">try_of_catch</h4>
<p>try_of 可以对返回结果进行模式匹配，相当于<code>case func() of</code>的语法糖。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">	do_stuff_return()</div><div class="line"><span class="keyword">of</span></div><div class="line">	<span class="number">0</span> -&gt; pass;</div><div class="line">	<span class="variable">Result</span> -&gt; pass</div><div class="line"><span class="keyword">catch</span></div><div class="line">	throw: <span class="variable">Other</span> -&gt; <span class="tuple">{get_throw, <span class="variable">Other</span>}</span>;</div><div class="line">	error: <span class="variable">Reason</span> -&gt; <span class="tuple">{get_error, <span class="variable">Reason</span>}</span>;</div><div class="line">	exit: <span class="variable">Reason</span> -&gt; <span class="tuple">{get_exit, <span class="variable">Reason</span>}</span></div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>    

<h4 id="after">after</h4>
<p>after相当于Java的finally。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">	do_stuff()</div><div class="line"><span class="keyword">catch</span></div><div class="line">	throw: <span class="variable">Other</span> -&gt; <span class="tuple">{get_throw, <span class="variable">Other</span>}</span>;</div><div class="line">	error: <span class="variable">Reason</span> -&gt; <span class="tuple">{get_error, <span class="variable">Reason</span>}</span>;</div><div class="line">	exit: <span class="variable">Reason</span> -&gt; <span class="tuple">{get_exit, <span class="variable">Reason</span>}</span></div><div class="line"><span class="keyword">after</span></div><div class="line">	clean()</div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>    

<h3 id="2-_Process_link">2. Process link</h3>
<blockquote>
<p>本节为预备知识</p>
</blockquote>
<p>Erlang process之间有个重要的关系叫link，请记住，这是一个双向的关系。有时开玩笑会说，不link则已，一link则挂。</p>
<p>当两个进程link起来后，其中一方进程崩溃了产生 exit 信号，这个 exit 会被另一方进程 trap 住，然后一同挂掉。当然，有的进程trap 到了 exit 信号不一定打算同归于尽，他可以去做其他事情比如汇报异常、重启挂掉的进程等，这种进程的角色叫做supervisor，后面会提到。</p>
<p>link 一般有两种方式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">link</span><span class="params">(<span class="variable">PidOrPort</span>)</span> -&gt;</span> <span class="literal">true</span></div><div class="line"><span class="comment">% Types: PidOrPort = pid() | port()</span></div></pre></td></tr></table></figure>    

<p>Creates a link between the calling process and another process (or port) PidOrPort,     if there is not such a link already. If a process attempts to create     a link to itself, nothing is done. Returns true.</p>
<p>或者：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% Fun : function()</span></div><div class="line"><span class="comment">% Node: node()</span></div><div class="line"><span class="comment">% Module = module()</span></div><div class="line"><span class="comment">% Args = [term()]</span></div><div class="line"><span class="function"><span class="title">spawn_link</span><span class="params">(<span class="variable">Fun</span>)</span> -&gt;</span> <span class="function_name">pid</span>(),</div><div class="line"><span class="function_name">spawn_link</span>(<span class="variable">Node</span>, <span class="variable">Fun</span>) -&gt; <span class="function_name">pid</span>(),</div><div class="line"><span class="function_name">spawn_link</span>(<span class="variable">Module</span>, <span class="variable">Function</span>, <span class="variable">Args</span>) -&gt; <span class="function_name">pid</span>(),</div><div class="line"><span class="function_name">spawn_link</span>(<span class="variable">Node</span>, <span class="variable">Module</span>, <span class="variable">Function</span>, <span class="variable">Args</span>) -&gt; <span class="function_name">pid</span>().</div></pre></td></tr></table></figure>    

<h3 id="3-_Erlang-way_error_handling">3. Erlang-way error handling</h3>
<blockquote>
<p>本节及之后为核心内容</p>
</blockquote>
<p>我们先来看一段来自 Erlang Mailing List 2014.11.24 的邮件原文：</p>
<blockquote>
<p>The try-catch syntax was deliberately chosen to be reminiscent of<br>Java, the idea being that if you understood this try-catch consequence<br>in Java you’d easily understand the Erlang code.</p>
<p>The problem I see with this is that programmers with previous<br>experience in Java are tempted to blindly convert sequential try-catch<br>code in Java into sequential try-catch code in Erlang, but this is<br>almost always the wrong thing to do.</p>
<p>Beginners should be forbidden to use try-catch - the Erlang “way” is<br>to spawn_link a regular process (ie a process that does not trap<br>exits) and just let that process die if anything goes wrong. There<br>should be no error trapping code in the spawned process. Call<br>exit(Why) in every place where the behaviour is unspecified.</p>
<p>—— By Joe Armstrong</p>
</blockquote>
<p>Joe Armstrong何许人也，据说他的简历只需要三个词 —— I wrote Erlang。</p>
<p>Joe 极力劝告大家不要使用try-catch结构来做错误处理，其实文中forbidden一词稍有点极端，在某些譬如做socket或做io的时候可能需要一些失败后的收尾工作，这时还是要借助catch。但是catch后最后还是建议让进程fail掉，因为那才是Erlang-way的容错处理，也就是Actor模式中常讲的“Let it crash”。</p>
<p>crash后的进一步错误处理就依靠上节提到的进程链接。那么这种同归于尽式的link有什么好处呢？通过link我们实际可以构建出一组进程（其实就是构建了一颗双向连通的进程树型结构），该组进程里的任一进程挂掉都会使整组进程挂掉。实际上这就是控制了错误的传播。在很多时候，某个进程计算出错了，相关的进程的状态其实也是有问题的，与其在每一步都去思考出错的可能情况去catch做处理，还不如挂掉重启，反正你跑下去也是有问题的。再者，Erlang的设计本来就是不停地新建进程和销毁进程，每一个小型任务可以的话一般都会分出去新建进程去跑。Erlang进程不同于OS级别的进程线程，调度开销很低。因此，Erlang社区的开发者都会建议你通过link来传播进程的exit信号，从而实现容错处理。</p>
<p>Erlang 里还有个术语叫做 error kernel，指的是整个系统程序里决不能出错的核心部分（一出错整个系统就完蛋，没有挽救机会的那种）。error kernel的要求是规模尽可能小，并且发布后默认是可信任的；其他一些计算类任务都要尽可能从error kernel剥离。因此，error kernel占系统的比例大小是评估整个系统Erlang实现的鲁棒性的重要标准。</p>
<p>有一种形象化的比喻：把整个系统看做一个个方格拼成的广场，error kernel部分的方格是红色的。还有一些比如起顶端supervisor角色作用的模块，或一些可能出严重错误但还未严重到使系统崩溃的模块进程，它们也被标成红色的。其他允许挂掉的进程我们标为白色。Erlang系统的鲁棒性的一个形象体现就在于红色方块越少，系统越健壮。</p>
<h3 id="4-_OTP_supervisor_tree">4. OTP supervisor tree</h3>
<p>上文我们反复提到一个词叫做supervisor，中文叫监管者/监督者。我们所创建的Erlang process一般有两种，supervisor和worker。worker很简单，就是实际执行任务的进程。supervisor的职责有：监控子进程状态并在其挂掉后做错误处理、exit信号隔离以及重启策略。</p>
<p>OTP给Erlang带来了很多特性，其中一个非常重要的是supervisor tree监管树。</p>
<p><img src="http://images.cnitblog.com/blog/527700/201411/251430414967138.png" alt="image"></p>
<p>如图所示，在 Process link 一节中曾提到多个进程link成一个树形结构的进程组，便是图中的一棵子树。supervisor下的某个子树挂了，不会影响到其他无关的进程组，同时supervisor还可以帮助重启。supervisor也可以监管supervisor形成多级监管。总而言之有如下特性：</p>
<ol>
<li>子进程受父进程监管，其退出信号会传递给父进程。</li>
<li>父进程收到子进程的退出信号时，可以决定是将信号继续传递还是自行处理。</li>
<li>父进程若决定自行处理则会按照配置的重启策略去重启子进程。</li>
</ol>
<p>OTP提供的默认 behaviour 中就有 supervisor，让用户很方便的去实现基本的 supervisor 进程。OTP允许监督者按预设的方式和次序来启动进程。用户还可以告知监督者如何在单个进程故障时重启其他进程、一段时间内尝试重启多少次后放弃重启等。</p>
<h3 id="5-_Restart_process">5. Restart process</h3>
<p>我们一直在强调要重启进程，但是重启我们就不得不面对一个问题，旧进程的状态怎么办？正所谓一个计算过程或函数一般都需要输入才能有输出，重启后输入怎么办？</p>
<p>这里我们要将进程内的状态分为三种来考虑：</p>
<ol>
<li>Internal State，又叫 Stack State。就是一些临时变量或存储在栈上的内容。这部分状态我们实际是不期望保留的，一般最多用来做点错误追踪，因为同样的栈再去跑还是同样的错误。</li>
<li>Static State，或 Global State。这里比较类似Java里的一些常量、静态变量等，比如像TCP的端口地址配置之类的。这部分状态应该是做好配置存储的，比如放到ETS里，一般全局存储后可以轻易拿回。</li>
<li>Dynamic State。比如说一些计算结果或用户输入。计算结果还好，只要可以重计算的问题都不大。比较麻烦的是像用户输入一类的没办法轻易取回的数据，总不能叫用户再输入一次吧。这部分数据状态就需要开发者自己比较小心。在识别出该进程可能挂掉会丢失该类数据后，如果有需要应该将其进行一定的缓存，这样重启时也可以去找回，等到计算结束后再清除缓存。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers |  Erlang error handling | 说到容错处理，大概大家都会想到 `try-catch` 类结构，对于绝大多数传统语言来说，确实是这样。但是对于Erlang来说，容错处理是其一个核心特性，真正涉及到的是整个系统的设计，与 `try-catch` 无关；其核心是Erlang进程本身的特性以及进程链接。]]>
    
    </summary>
    
      <category term="erlang" scheme="http://pinghackers.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Erlang初学者技巧及避免的陷阱]]></title>
    <link href="http://pinghackers.com/2014/11/24/erlang-beginner-tricks/"/>
    <id>http://pinghackers.com/2014/11/24/erlang-beginner-tricks/</id>
    <published>2014-11-24T15:41:36.000Z</published>
    <updated>2014-11-27T08:35:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：吴文杰</p>
<p><strong>原文链接</strong>：<a href="http://pinghackers.com/2014/11/24/erlang-beginner-tricks/" target="_blank" rel="external">http://pinghackers.com/2014/11/24/erlang-beginner-tricks/</a></p>
<p><strong>本文同时也发布在</strong>：<a href="http://www.cnblogs.com/lhfcws/p/4116507.html" target="_blank" rel="external">http://www.cnblogs.com/lhfcws/p/4116507.html</a></p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h3 id="前言">前言</h3>
<p>Erlang对于大多数同学来说都是相对较陌生的语言，因为其函数式特性以及语法内置并发，很多传统语言的经验无法应用到Erlang上。笔者便稍微小结一下部分初学者容易遇到的坑或疑惑。</p>
<h3 id="目录">目录</h3>
<ol>
<li>传参或在匿名函数内慎用self()</li>
<li>Message Passing支持发送Socket、文件句柄等对象引用消息</li>
<li>在不需追踪函数状态的时候，尽量使用尾递归</li>
<li>动态创建原子要十分谨慎</li>
<li>巧用原子作模式匹配</li>
<li>特殊字符使用$开头，如$\n。</li>
<li>大型数据慎用消息传递，有必要可考虑ETS表做进程共享</li>
<li>跨机器间的进程消息发送要小心，小型消息频率过高TCP头部的发送代价也高。</li>
<li>函数传参记得参数相对应</li>
<li>列表操作要谨慎</li>
</ol>
<h4 id="1-_传参或在匿名函数内慎用self()">1. 传参或在匿名函数内慎用self()</h4>
<p>通常在做消息传递或新建进程的时候我们需要将当前进程的Pid发给目标进程以便接收返回信息，但初学者不留意容易犯以下错误</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">spawn</span><span class="params">(<span class="keyword">fun</span>() -&gt;</span></span></div><div class="line">   	<span class="function_name">loop</span>(<span class="function_name">self</span>(), <span class="function_name">gen_tcp:accpet</span>(...))</div><div class="line"><span class="keyword">end</span>).</div></pre></td></tr></table></figure>    

<p>fun这段代码在本进程内是不会预先执行的，代码会原封不动传给目标进程。当实际调用self()的时候，获取的实际不是本进程的Pid了。</p>
<p>所以建议当需要传递当前进程Pid或者其他当前进程类似函数的时候，先求值再传递。保持良好习惯就可以避免类似的坑。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">Pid</span> = self(),</div><div class="line"><span class="variable">Socket</span> = gen_tcp:accpet(...),</div><div class="line"><span class="function"><span class="title">spawn</span><span class="params">(<span class="keyword">fun</span>() -&gt; </span></span></div><div class="line">   	<span class="function_name">loop</span>(<span class="variable">Pid</span>, <span class="variable">Socket</span>)</div><div class="line"><span class="keyword">end</span>).</div></pre></td></tr></table></figure>


<a id="more"></a> 



<h4 id="2-_Message_Passing支持发送Socket、文件句柄等对象引用消息">2. Message Passing支持发送Socket、文件句柄等对象引用消息</h4>
<p>稍微了解Erlang的同学都知道Erlang消息传递目标进程接收的实际是发送进程消息的一个拷贝副本，对于存储类数据这个没有问题。</p>
<p>当对于Socket，FileHandler这类对象的时候，事实上也是可以传递并能起到预期效果的。</p>
<p>（以下Demo代码来自Erlang的Mailing List）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%This is an example of how trivial writing a FTP-like client in Erlang.</span></div><div class="line"></div><div class="line"><span class="comment">%On machine 1. </span></div><div class="line"><span class="variable">File</span> = file:open(<span class="variable">FileName</span>, [read]).</div><div class="line"><span class="variable">PidOfProcessOnMachine2</span> ! <span class="tuple">{remote_file, <span class="variable">File</span>}</span>.</div><div class="line"></div><div class="line"><span class="comment">%On machine 2.</span></div><div class="line"><span class="keyword">receive</span></div><div class="line">    <span class="tuple">{remote_file, <span class="variable">File</span>}</span> -&gt;</div><div class="line">       <span class="tuple">{ok, <span class="variable">Data</span>}</span> = file:read(<span class="variable">File</span>, <span class="number">1000000</span>),</div><div class="line">       write_to_local_disk(<span class="variable">Data</span>)</div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure> 

<h4 id="3-_在不需追踪函数状态的时候，尽量使用尾递归">3. 在不需追踪函数状态的时候，尽量使用尾递归</h4>
<p>众所周知，Erlang是没有循环结构的，我们要想实现循环基本是靠递归实现的。但又众所周知，函数递归是要不停压栈的，我们要想实现 while(true)怎么办？</p>
<p>答案就是尾递归，许多这类语言都已在编译器层面实现了尾递归优化，在编译器识别出尾递归后，编译器会直接丢掉当前函数状态信息变成做跳转，这里汇编层面其实就和循环结构很类似了。</p>
<p>但尾递归也有个缺点，就是函数状态没法保留了，所以有时候复杂情况需要追踪调试函数栈状态的时候就不能用尾递归。但其实在Erlang这类函数式语言里，尾递归大多数情况是用来实现循环，所以实际上也不需要留意函数栈。</p>
<h4 id="4-_动态创建原子要十分谨慎">4. 动态创建原子要十分谨慎</h4>
<p>Erlang里有一种特殊的结构叫做原子（atom），一般用来做类似传统语言里的常量作用或用来辅助模式匹配。</p>
<p>Erlang默认有几百万个内置原子，但是Erlang除非整个VM退出了，否则是不会对任何原子做GC的。</p>
<p>所以有时候我们为了匹配会使用 list_to_atom 函数去动态创建原子，但这是很危险的，甚至有可能导致内存泄露。</p>
<p>所以除非你自己很清醒自己的所作所为并且考虑到别人对你代码的调用情况，否则尽量不要动态创建原子。</p>
<p>但静态创建原子是没问题的，毕竟你手动打的数目总是极其有限，比如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">receive</span></div><div class="line">   	<span class="tuple">{my_own_atom, <span class="variable">Var</span>}</span> -&gt; pass.</div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>    

<p>但谨慎出现以下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% On machine 1</span></div><div class="line"></div><div class="line"><span class="variable">Type</span> = recv(),</div><div class="line"><span class="variable">Msg</span> = recv(),</div><div class="line"><span class="variable">Machine2</span> ! <span class="tuple">{<span class="function_name">list_to_atom</span>(<span class="variable">Type</span>), <span class="variable">Msg</span>}</span>.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">% On machine 2</span></div><div class="line"></div><div class="line"><span class="keyword">receive</span></div><div class="line">   	<span class="tuple">{type1, <span class="variable">Msg</span>}</span> -&gt; pass;</div><div class="line">    <span class="tuple">{type2, <span class="variable">Msg</span>}</span> -&gt; pass</div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>    

<p>这里的Type很容易成为受攻击的对象。</p>
<h4 id="5-_巧用原子作模式匹配">5. 巧用原子作模式匹配</h4>
<p>经常我们要解析协议或者匹配同等元素个数的元组列表，这时候可以用原子来进行区分实现模式匹配。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% Receiver</span></div><div class="line"><span class="variable">Packet</span> = recv(<span class="variable">Socket</span>),    <span class="comment">% Get TCP Packet</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">Packet</span> <span class="keyword">of</span></div><div class="line">   	[new_user, <span class="string">"||"</span>, <span class="variable">Username</span>] -&gt;</div><div class="line">        pass;</div><div class="line">   	[new_board, <span class="string">"||"</span>] -&gt;</div><div class="line">       	pass.</div><div class="line"><span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% Sender</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">send</span><span class="params">([new_user, <span class="string">"||"</span>, <span class="variable">Username</span>])</span>.</span></div></pre></td></tr></table></figure> 



<h4 id="6-_特殊字符使用$开头，如$\n。">6. 特殊字符使用$开头，如$\n。</h4>
<p>这个没什么好说，有需要去查看对应手册。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">Line</span> = io:get_line(<span class="string">"Input: "</span>),</div><div class="line"><span class="variable">S</span> = string:strip(<span class="variable">Line</span>, both, $\n).</div></pre></td></tr></table></figure> 



<h4 id="7-_大型数据慎用消息传递，有必要可考虑ETS表做进程共享">7. 大型数据慎用消息传递，有必要可考虑ETS表做进程共享</h4>
<p>Erlang有个口号叫“小消息 大计算”，所以使用Erlang期望传递的消息本来就是小消息。但我们经常也不可避免需要进程间共享一些大消息，这时候我们可以考虑从借助进程字典或ETS表。但其实Erlang的这种进程间只能通过MP通信的机制也逼迫我们在设计程序时要求每个进程的角色分工很明确。</p>
<h4 id="8-_跨机器间的进程消息发送要小心，小型消息频率过高TCP头部的发送代价也高。">8. 跨机器间的进程消息发送要小心，小型消息频率过高TCP头部的发送代价也高。</h4>
<p>这个其实还是见仁见智，根据实际业务情况而定。如果真的是因为TCP消耗引起的性能问题，就要考虑本地开个进程做代理，缓存一定的消息，定时批量发送。其实就是做个缓存队列。</p>
<p>可参见此文：<a href="http://avindev.iteye.com/blog/76373" target="_blank" rel="external">Erlang中频繁发送远程消息要注意的问题</a></p>
<h4 id="9-_函数传参记得参数相对应">9. 函数传参记得参数相对应</h4>
<p>这个没啥好说的，直接看代码。尽管fun匿名函数处理不需要参数，但for<em>内的F是个一元函数，所以也要至少用个</em>匹配符去代表那里有个参数。Erlang有另一种元调用方式apply（有点像JavaScript），apply传参是用个列表Args = […]，适用于较灵活的一些调用，比如spawn，但这种反射式调用一般效率都会较低，Erlang的apply据说比本地直接调用F()要慢上6 - 10倍。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">for_</span><span class="params">(<span class="variable">I</span>, <span class="variable">Max</span>, <span class="variable">F</span>)</span> -&gt;</span></div><div class="line">  	<span class="keyword">case</span> <span class="variable">I</span> == <span class="variable">Max</span> <span class="keyword">of</span></div><div class="line">   		<span class="literal">false</span> -&gt; [<span class="variable">F</span>(<span class="variable">I</span>) | <span class="function_name">for_</span>(<span class="variable">I</span> + <span class="number">1</span>, <span class="variable">Max</span>, <span class="variable">F</span>)];</div><div class="line">	    <span class="literal">true</span> -&gt; [<span class="variable">F</span>(<span class="variable">Max</span>)]</div><div class="line">	<span class="keyword">end</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">for_</span><span class="params">(<span class="number">0</span>, <span class="number">5</span>, <span class="keyword">fun</span>(<span class="variable">_</span>) -&gt;</span></span></div><div class="line">   	<span class="function_name">io:write</span>(<span class="string">"Hello Erlang"</span>)</div><div class="line"><span class="keyword">end</span>).</div></pre></td></tr></table></figure> 



<h4 id="10-_列表操作要谨慎">10. 列表操作要谨慎</h4>
<p>很多有其他类函数式语言（Python、Coffee等）经历的同学会很喜欢列表结构，但是Erlang的列表相对比较不同。</p>
<p>首先，Erlang的所有“变量”都是不可变也不可二次绑定的，所以想像Python那样自由操作list是不可能的，必须每次修改返回一个新变量。</p>
<p>列表右侧增长： </p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ++ [<span class="number">4</span>,<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],   </div><div class="line"><span class="string">"Hello"</span> ++ <span class="string">" "</span> ++ <span class="string">"Erlang"</span> = <span class="string">"Hello Erlang"</span></div></pre></td></tr></table></figure>

<p>++其实是lists:append/2的syntax sugar，切记和动态创建原子一样，可偶尔为之，但不要放任列表动态右侧增长。++会复制左边的元素，会使复制多次，最后导致平方倍的复杂度。</p>
<p>列表左侧增长：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> | [<span class="number">4</span>,<span class="number">5</span>]] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div></pre></td></tr></table></figure>

<p>不要和 [[1,2,3] | [4,5]] = [[1,2,3],4,5] 搞混。</p>
<p>列表length方法是O(N)时间复杂度，慎用length(List)，很多需求可以用模式匹配实现。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="variable">List</span> <span class="keyword">of</span></div><div class="line">   	[<span class="variable">Elem</span> | <span class="variable">_</span>] -&gt; process(<span class="variable">Elem</span>);</div><div class="line">    [] -&gt; process<span class="variable">EmptyList</span>() </div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>

<p>但是元组和二进制串的size方法却是O(1)的，可放心使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers |  Erlang 初学者技巧及避免的陷阱 | Erlang对于大多数同学来说都是相对较陌生的语言，因为其函数式特性以及语法内置并发，很多传统语言的经验无法应用到Erlang上。笔者便稍微小结一下部分初学者容易遇到的坑或疑惑。]]>
    
    </summary>
    
      <category term="erlang" scheme="http://pinghackers.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript基于时间的动画算法]]></title>
    <link href="http://pinghackers.com/2014/11/22/time-based-animation/"/>
    <id>http://pinghackers.com/2014/11/22/time-based-animation/</id>
    <published>2014-11-22T10:11:25.000Z</published>
    <updated>2014-11-22T13:26:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>前言</li>
<li>基于帧的动画算法（Frame-based）</li>
<li>基于时间的动画算法（Time-based）</li>
<li>改良基于时间的动画算法</li>
<li>总结</li>
</ul>
<h2 id="前言">前言</h2>
<p>前段时间无聊或有聊地做了几个移动端的HTML5游戏。放在不同的移动端平台上进行测试后有了诡异的发现，有些手机的动画会“快”一点，有些手机的动画会“慢”一点，有些慢得还不是一两点。</p>
<p>通过查找资料发现，基于帧的算法（Frame-based）来实现动画会导致不同帧率的平台体验不一致，而基于时间（Time-based）的动画算法可以很好地改良这种情况，让不同帧率的情况下都能达到较为统一的速度上的体验。</p>
<p>本文介绍的就是基于帧动画算法和基于时间动画算法的差异，以及对基于时间算法的改良。</p>
<h2 id="基于帧的动画算法（Frame-based）">基于帧的动画算法（Frame-based）</h2>
<p>相信做过前端的人对使用JavaScript实现动画的原理都很熟悉。现在让你实现一个让一个div从左到右来回移动的JS代码，你可能嗖嗖就写出来了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveDiv</span><span class="params">(div, fps)</span> </span>{</div><div class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> param = <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span> <span class="params">()</span> </span>{</div><div class="line">        update();</div><div class="line">        draw();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span> </span>{</div><div class="line">        left += param * <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (left &gt; <span class="number">300</span>) {</div><div class="line">            left = <span class="number">300</span>;</div><div class="line">            param = -<span class="number">1</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</div><div class="line">            left = <span class="number">0</span>;</div><div class="line">            param = <span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">draw</span><span class="params">()</span> </span>{</div><div class="line">        div.style.left = left + <span class="string">"px"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    setInterval(loop, <span class="number">1000</span> / fps);</div><div class="line">}</div><div class="line">moveDiv(<span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>), <span class="number">60</span>);</div></pre></td></tr></table></figure>

<a id="more"></a>

<p>效果如下：</p>
<div class="div green" id="div"></div>

<p>看看代码，我们让一个div在0 ～ 300px区间内左右来回移动。<code>update</code>计算更新描绘div的位置，<code>draw</code>重新描绘页面上的div。为了方便起见，这里直接使用<code>setInterval</code>作为定时器，实际情况下可以采用你喜欢的<code>setTimeout</code>或者<code>requestAnimationFrame</code>。这里设置每秒钟到更新60次，60fps是人尽皆知的比较适合做动画的帧率。</p>
<p>地球人都知道，JavaScript中的定时器是不准确的。由于JavaScript运行时需要耗费时间，而JavaScript又是单线程的，所以如果一个定时器如果比较耗时的话，是会阻塞下一个定时器的执行。所以即使你这里设置了<code>1000 / 60</code>每秒60帧的帧率，在不同的浏览器平台的差异也会导致实际上你的没有60fps的帧率。</p>
<p>所以上面代码在一个手机上执行的时候可能有60fps的帧率，在另外一个手机上可能就只有30fps，更甚可能只有10fps。</p>
<p>我们模拟一下这种情况会有什么效果发生：</p>
<div class="title">60 fps:</div><br><div class="div green" id="div1"></div>

<div class="title">30 fps:</div><br><div class="div red" id="div2"></div>

<div class="title">10 fps:</div><br><div class="div blue" id="div3"></div>


<p>这完全不对大头！</p>
<p>可以看到三个方块移动速度根本不在同一个channel上。想象一下一个超级马里奥游戏在10fps的情况会怎么样？按跳跃一下，你会看到马里奥以一种太空漫游的姿态在空中抛弧线。</p>
<p>导致这种情况的原因很简单，因为我们计算和绘制每个div位置的时候是在每帧更新，每帧移动2px。在60fps的情况下，我们1秒钟会执行60帧，所以小块每秒钟会移动60 * 2 = 120px；如果是30fps，小块每秒就移动30 * 2 = 60px，以此类推10fps就是每秒移动20px。</p>
<p>三个小块在单位时间内移动的距离不一样！</p>
<p>假如你现在要做一个超级马里奥的游戏，怎么做到可以在不同帧率的情况下让马里奥看起来还是那么迅速且帅气？</p>
<p>解决方案很明显。虽然不同的浏览器平台上的运行差异可能会导致帧率的不一致，但是有一样东西是在任何平台上都一致的，那就是时间。所以我们可以改良我们的算法，不是以帧为基准来更新方块的位置，而是以时间为单位更新。也就是说，我们之前是<code>px/frame</code>，现在换成<code>px/ms</code>。</p>
<p>这就是接下来要说的基于时间（Time-based）的动画算法。</p>
<h2 id="基于时间的动画算法（Time-based）">基于时间的动画算法（Time-based）</h2>
<p>其实思路和实现都很简单。我们计算每一帧离上一帧过去了多少时间，然后根据过去的时间来更新方块的位置。</p>
<p>例如，上面的方块应该每秒钟移动120px，每毫秒移动120 / 1000 = 0.12像素（12px/ms）。如果上一帧方块的位置在left为10px的位置，到了这一帧的时候，假设相对于上一帧来说时间过去了200ms，那在时间上来说在这一帧方块应该移动200ms * 0.12px/ms = 240px。最终位置应该为10 + 240 = 250px。其实就是<code>left = left + detalTime * speed</code>。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveDivTimeBased</span><span class="params">(div, fps)</span> </span>{</div><div class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> current = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">var</span> previous = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">var</span> param = <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">var</span> current = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">        <span class="keyword">var</span> dt = current - previous; <span class="comment">// 计算时间差</span></div><div class="line">        previous = current;</div><div class="line">        update(dt);</div><div class="line">        draw()</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">(dt)</span> </span>{</div><div class="line">        left += param * (dt * <span class="number">0.12</span>); <span class="comment">// 根据时间差更新位置</span></div><div class="line">        <span class="keyword">if</span> (left &gt; <span class="number">300</span>) {</div><div class="line">            left = <span class="number">300</span>;</div><div class="line">            param = -<span class="number">1</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</div><div class="line">            left = <span class="number">0</span>;</div><div class="line">            param = <span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }        </div><div class="line">               </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">draw</span><span class="params">()</span> </span>{</div><div class="line">        div.style.left = left + <span class="string">"px"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    setInterval(loop, <span class="number">1000</span> / fps);</div><div class="line">}</div></pre></td></tr></table></figure>


<p>看看效果如何：</p>
<div class="title">60 fps:</div><br><div class="div green" id="div4"></div>

<div class="title">30 fps:</div><br><div class="div red" id="div5"></div>

<div class="title">10 fps:</div><br><div class="div blue" id="div6"></div>

<p>看起来比上面的好多了，30fps和10fps好像能勉强赶上60fps的步伐。但是时间久了会发现30fps和10fps越来越落后于60fps。（建议先刷新再看看效果会更加明显）</p>
<p>这是因为<strong>每次小方块碰到边缘的时候，都会损失掉一部分时间，而且帧率越低的损失越大。</strong>看看我们上面的<code>update</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">(dt)</span> </span>{</div><div class="line">    left += param * (dt * <span class="number">0.12</span>); <span class="comment">// 根据时间差更新位置</span></div><div class="line">    <span class="keyword">if</span> (left &gt; <span class="number">300</span>) {</div><div class="line">        left = <span class="number">300</span>;</div><div class="line">        param = -<span class="number">1</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</div><div class="line">        left = <span class="number">0</span>;</div><div class="line">        param = <span class="number">1</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>假如我们现在方块的位置在left为290px的位置，这一帧传入的dt为100ms，那么我们left为290 + 100 * 0.12 = 302，但是302大于300，所以left会被设置为300。那么本来用来移动2px的时间就会白白被“抛弃”掉。dt越大，浪费得越多，所以30fps和10fps会比60fps越来越慢。</p>
<p>为了解决这个问题，我们对已有的算法进行改良。</p>
<h2 id="改良基于时间的动画算法">改良基于时间的动画算法</h2>
<p>解决思路如下：不一次算整块的时间（dt）移动的距离，而是把dt分成固定的时间片，通过多次update固定的时间片来计算dt时间后应该到什么位置。</p>
<p>比较抽象，我们直接看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveDivTimeBasedImprove</span><span class="params">(div, fps)</span> </span>{</div><div class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> current = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">var</span> previous = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">var</span> dt = <span class="number">1000</span> / <span class="number">60</span>;</div><div class="line">    <span class="keyword">var</span> acc = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> param = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">var</span> current = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">        <span class="keyword">var</span> passed = current - previous;</div><div class="line">        previous = current;</div><div class="line">        acc += passed; <span class="comment">// 累积过去的时间</span></div><div class="line">        <span class="keyword">while</span>(acc &gt;= dt) { <span class="comment">// 当时间大于我们的固定的时间片的时候可以进行更新</span></div><div class="line">            update(dt); <span class="comment">// 分片更新时间</span></div><div class="line">            acc -= dt;</div><div class="line">        }</div><div class="line">        draw();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// update 和 draw 函数不变</span></div><div class="line">    setInterval(loop, <span class="number">1000</span> / fps);</div><div class="line">}</div></pre></td></tr></table></figure>


<p>我们先确定一个固定更新的时间片，如固定为60fps时一帧的时间：1000 / 60 = 0.167ms。然后积累过去的时间，然后根据固定时间片分片进行更新。也就说，即使这一帧和上一帧相差过去了100ms，我也会把这100ms分成很多个0.167ms来执行update函数。这样做有两个好处：</p>
<ol>
<li>固定的时间片足够小，更新的时候可以减少边缘损失的时间。</li>
<li>不同帧率，不管你是60，30，还是10fps，也是根据固定时间片来执行update函数，所以即使有损失，不同帧率之间的损失是一样的。那么我们三个方块就可以达到同步移动的效果的了！</li>
</ol>
<p>看上面的代码，update和draw函数保持不变，而loop函数中，对过去的时间进行了累加，当时间超过固定的片就可以执行update。while循环可以保证更新直到把积累的时间都更新完。</p>
<p><strong>对时间进行积累，然后分固定片更新</strong>。这种方式还有一个非常大的好处，如果你的帧率超过了60fps，如达到100fps或者200fps，这时候passed会小于0.167ms，时间就会被积累，积累大于0.167才会执行更新。碉堡的效果就是：<strong>不管你的帧率是高还是低，移动速度都可以和60fps情况下的速度同步。</strong></p>
<p>看看最后的效果：</p>
<div class="title">60 fps:</div><br><div class="div green" id="div7"></div>

<div class="title">30 fps:</div><br><div class="div red" id="div8"></div>

<div class="title">10 fps:</div><br><div class="div blue" id="div9"></div>

<p>还是蛮不错的。</p>
<h2 id="总结">总结</h2>
<p>基于帧的动画算法会在帧率不同的情况下导致动画体验有较大的差异，所有动画都应该基于时间进行执行。而基于时间的动画算法要注意边缘时间的损失，最好采取积累时间，然后分固定片更新动画的方式。</p>
<h2 id="References">References</h2>
<ul>
<li><a href="http://gafferongames.com/game-physics/fix-your-timestep/" target="_blank" rel="external">http://gafferongames.com/game-physics/fix-your-timestep/</a></li>
<li><a href="http://blog.sklambert.com/using-time-based-animation-implement/" target="_blank" rel="external">http://blog.sklambert.com/using-time-based-animation-implement/</a></li>
<li><a href="http://viget.com/extend/time-based-animation" target="_blank" rel="external">http://viget.com/extend/time-based-animation</a></li>
<li><a href="http://codetheory.in/time-based-animations-in-html5-games-why-and-how-to-implement-them/" target="_blank" rel="external">http://codetheory.in/time-based-animations-in-html5-games-why-and-how-to-implement-them/</a></li>
</ul>
<p>（全文完）</p>
 <style type="text/css">
    .div {
        width: 30px;
        height: 20px;
        position: relative;
    }
    .green {
        background-color: green;
    }
    .red {
        background-color: red;
    }
    .blue {
        background-color: blue;
    }
</style>

<script type="text/javascript">
function moveDiv(div, fps) {
    var left = 0;
    var param = 1;
    function loop () {
        update();
        draw();
    }
    function update() {
        left += param * 2;
        if (left > 300) {
            left = 300;
            param = -1;
        } else if (left < 0) {
            left = 0;
            param = 1;
        }
    }
    function draw() {
        div.style.left = left + "px";
    }
    setInterval(loop, 1000 / fps);
}
moveDiv(document.getElementById("div"), 60);
moveDiv(document.getElementById("div1"), 60);
moveDiv(document.getElementById("div2"), 30);
moveDiv(document.getElementById("div3"), 10);
</script>
<script type="text/javascript">
function moveDivTimeBased(div, fps) {
    var left = 0;
    var current = +new Date;
    var previous = +new Date;
    var param = 1;
    function loop() {
        var current = +new Date;
        var dt = current - previous;
        previous = current;
        update(dt);
        draw()
    }
    function update(dt) {
        left += param * (dt * 0.12);
        if (left > 300) {
            left = 300;
            param = -1;
        } else if (left < 0) {
            left = 0;
            param = 1;
        }
    }
    function draw() {
        div.style.left = left + "px";
    }
    setInterval(loop, 1000 / fps);
}

moveDivTimeBased(document.getElementById("div4"), 60);
moveDivTimeBased(document.getElementById("div5"), 30);
moveDivTimeBased(document.getElementById("div6"), 10);
</script>

<script type="text/javascript">
    function moveDivTimeBasedImprove(div, fps) {
        var left = 0;
        var current = +new Date;
        var previous = +new Date;
        var dt = 1000 / 60;
        var acc = 0;
        var param = 1;

        function loop() {
            var current = +new Date;
            var passed = current - previous;
            previous = current;
            acc += passed;
            while(acc >= dt) {
                update(dt);
                acc -= dt;
            }
            draw();
        }

        function update (dt) {
            left += param * (dt * 0.12);
            if (left > 300) {
                left = 300;
                param = -1;
            } else if (left < 0) {
                left = 0;
                param = 1;
            }
        }

        function draw() {
            div.style.left = left + "px";
        }

        setInterval(loop, 1000 / fps);
    }

moveDivTimeBasedImprove(document.getElementById("div7"), 60);
moveDivTimeBasedImprove(document.getElementById("div8"), 30);
moveDivTimeBasedImprove(document.getElementById("div9"), 10);
</script>

]]></content>
    <summary type="html">
    <![CDATA[PingHackers | JavaScript基于时间的动画算法 | 基于帧的算法（Frame-based）来实现动画会导致不同帧率的平台体验不一致，而基于时间（Time-based）的动画算法可以很好地改良这种情况，让不同帧率的情况下都能达到较为统一的速度上的体验。]]>
    
    </summary>
    
      <category term="animation" scheme="http://pinghackers.com/tags/animation/"/>
    
      <category term="javascript" scheme="http://pinghackers.com/tags/javascript/"/>
    
      <category term="web" scheme="http://pinghackers.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之函数指针的使用及注意事项]]></title>
    <link href="http://pinghackers.com/2014/11/18/cpp-function-pointer/"/>
    <id>http://pinghackers.com/2014/11/18/cpp-function-pointer/</id>
    <published>2014-11-18T15:41:36.000Z</published>
    <updated>2014-11-22T13:22:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>背景介绍</li>
<li>函数指针基本知识</li>
<li>函数指针的注意事项</li>
<li>函数指针的用途</li>
<li>标准库与函数指针</li>
</ul>
<h2 id="背景介绍">背景介绍</h2>
<p>和老板聊天中，偶然谈到函数指针，惊觉自己在这方面的能力不足，偶尔以前也听潘炎教授谈到过函数指针的重要性，因此写下这篇博客。</p>
<p>在小型的工程代码中，函数指针的出镜率往往是非常小甚至是没有的。然而如果工程的规模比较大，则会发现函数指针会在多处使用。因此掌握函数指针对于每一个C++开发者来说都是一项必须的技能。</p>
<a id="more"></a>

<h2 id="函数指针基本知识">函数指针基本知识</h2>
<p>我们通过如下方法声明一个指向特定类型函数的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (* fp)(<span class="keyword">int</span>);                         <span class="comment">// pointer to a function</span></div></pre></td></tr></table></figure>

<p>要注意的是<strong>括号是不可缺少的</strong>，它表明fp是一个指向返回值为void的函数的指针，而不是返回值为void * 的函数。</p>
<p>函数指针既然是指针，就意味着它可以为空，否则它应该指向一个具有适当类型的函数，下面一段代码揭示了函数指针的使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> f ( <span class="keyword">int</span> );</div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> g ( <span class="keyword">long</span> );</div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> h (<span class="keyword">int</span> );</div><div class="line"></div><div class="line">fp = f ;               <span class="comment">//  Wrong! int (*)(int) instead of void (*)(int)</span></div><div class="line">fp = g ;               <span class="comment">//  Wrong! void (*)(long) instead of void (*)(int)</span></div><div class="line">fp = <span class="number">0</span> ;              <span class="comment">//  OK</span></div><div class="line">fp = h ;               <span class="comment">//  OK</span></div><div class="line">fp = &amp;h;              <span class="comment">//  OK, assign the address of the function explicitly to fp</span></div></pre></td></tr></table></figure>

<h2 id="函数指针的注意事项">函数指针的注意事项</h2>
<p>在上面的代码中，前面的三个函数声明很好理解，紧随其后的两行赋值代码会出错——由于类型的不匹配，而接下来的两行代码是简单的赋值，不会出问题。</p>
<p>需要注意的是最后一行代码……<strong>在函数指针中，把一个函数的地址初始化或者赋值给一个指向函数的指针的时候，不需要显式使用&amp;符号取得函数的地址</strong>——编译器是知道隐式获得函数地址的。因此在这种情况下，&amp;操作符是可有可无的，一般来说是省略不用。</p>
<p>同样的，为了调用函数指针所指向的函数，我们也不需要对指针进行解引用，看下面两行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(* fp)( <span class="number">12</span> );           <span class="comment">//  explicit dereference</span></div><div class="line">fp(<span class="number">12</span> );                <span class="comment">//  OK, implicit dereference</span></div></pre></td></tr></table></figure>

<p>上面两种都是正确的操作。</p>
<p>对于数据来说，void* 指针可以指向任何类型的数据。可是对于函数来说，<strong>不存在可以指向任何类型函数的通用指针</strong>。此外值得一提的是，<strong>在一个类中的非静态成员函数的地址并不是一个指针</strong>，因此不可以把一个函数指针指向一个非静态成员函数。这也就是为什么回调函数一般不会写在类里面的原因。</p>
<p>什么？你问我指向成员函数的指针是个什么东西？其实指向类中的指针应该是一个需要深入讨论的问题，这个今天不讨论，改天我找到女朋友了心情好了再写一篇博客^o^。不过大致的来讲可以把指向类中成员的指针视作一个偏移量，指向类中函数成员的指针通常可以被是视为一个包含了信息的结构。解引用又是一个蛋疼的问题，在这里就不讨论了……</p>
<h2 id="函数指针的用途">函数指针的用途</h2>
<p>函数指针的一种传统的用途是实现回调，也就是我们所说的callback函数（有兴趣的童鞋可以阅读设计模式中的command命令模式来深入了解回调技术）。所谓的一个回调函数就是一个可能的动作，而这个动作在初始化的时候就被设置好来应对将来可能发生的事情。</p>
<p>举个栗子，如果你饿了，那么我们如果希望对自己饿了这个情况作出反应，那么我们可以预先设定好我们的应对情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> eatApple ();</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> eatDumpling ();</div><div class="line"></div><div class="line"><span class="keyword">void</span> (* HungryAction )() = <span class="number">0</span> ;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( Hungry ){</div><div class="line">     <span class="keyword">if</span> ( gotKnife )</div><div class="line">        HungryAction = eatApple ;</div><div class="line">     <span class="keyword">else</span></div><div class="line">        HungryAction = eatDumpling ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果我们决定了要执行的动作，那么我们就可以在代码中的另一个部分专注于是否去执行操作以及何时去执行操作了，我们无需关心这个动作到底是吃苹果还是吃饺子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Hungry ){</div><div class="line">     <span class="keyword">if</span> ( HungryAction )</div><div class="line">        HungryAction ();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我在上面的函数中特意声明了一个内联函数，这是为了告诉大家，讲一个函数指针指向内联函数是完全合法的。但是，如果通过函数指针调用内联函数不会导致内联调用。这个原理其实很简单，因为编译器是无法在编译期就精确的确定将会调用什么函数的。在上面的例子中，HungryAction可能指向两个函数的任意一个，当然也可能是空的，因此在调用点，编译器只能生成间接非内联的函数调用机器代码。</p>
<p>还有要注意的地方（卧槽你有完没完！）……函数指针可以指向一个重载函数的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> eatApple ();</div><div class="line"><span class="keyword">void</span> eatApple (Knife knife );</div><div class="line">HungryAction = eatApple ;</div></pre></td></tr></table></figure>

<p>那么在不同的候选函数中，函数指针将在被使用的时候挑一个最匹配的。由于我们上面的函数类型是void (*)()，因此选择的是第一个eatApple()函数。</p>
<h2 id="标准库与函数指针">标准库与函数指针</h2>
<p>曾经看侯捷教授的《STL源码剖析》中看到，在STL标准库中，使用了函数指针用于回调机制的地方不能算少——最突出的就是被set_new_handler用于设置回调。</p>
<p>当new函数无法履行一个内存分配的请求（大部分原因是由于内存不足）时，就会调用到一个回调函数，用于报告此时的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> begForgiveness ()</div><div class="line">{</div><div class="line">    logError ( <span class="string">"I'm Sorry! "</span> );</div><div class="line">     <span class="keyword">throw</span> <span class="built_in">std</span> :: bad_alloc ();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">std</span> ::new_handler oldHandler = std:: set_new_handler ( begForgiveness );</div><div class="line"></div><div class="line">myHouse.add( <span class="keyword">new</span> girlFriend ( <span class="number">1000000000</span> ));</div></pre></td></tr></table></figure>

<p>吐槽代码你就输了……</p>
<p>BTW，标准类型的名称中的new_handler实际上就是一个typedef：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*new_handler )();</div></pre></td></tr></table></figure>

<p>因此，回调函数必须是一个不带参数并且返回void的函数。set_new_handler函数会将回调设置为参数，并且返回前一个回调，这也就是所谓的获得当前回调的“回旋式手法”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span> ::new_handler current = std:: set_new_handler (<span class="number">0</span> );      <span class="comment">//   获取</span></div><div class="line"><span class="built_in">std</span> ::set_new_handler ( current );                           <span class="comment">//   恢复</span></div></pre></td></tr></table></figure>

<p>扯一句题外话，set_terminate和set_unexpected也是使用了这种回旋手法……不过还是等到找到第二个女朋友再扯这个话题吧……</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | C++学习之函数指针的使用及注意事项 | 在小型的工程代码中，函数指针的出镜率往往是非常小甚至是没有的。然而如果工程的规模比较大，则会发现函数指针会在多处使用。因此掌握函数指针对于每一个C++开发者来说都是一项必须的技能。]]>
    
    </summary>
    
      <category term="C++" scheme="http://pinghackers.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之RAII编程思想]]></title>
    <link href="http://pinghackers.com/2014/11/16/cpp-raii/"/>
    <id>http://pinghackers.com/2014/11/16/cpp-raii/</id>
    <published>2014-11-16T15:27:39.000Z</published>
    <updated>2014-11-22T13:22:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：左君博</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ul>
<li>背景介绍</li>
<li>先说一点C++</li>
<li>总体概念<ul>
<li>举个RAII栗子</li>
<li>实际操作之反栗 </li>
<li>实际操作之正栗</li>
</ul>
</li>
</ul>
<h2 id="背景介绍">背景介绍</h2>
<p>在C++程序运行的过程中免不了要进行资源的分配——尤其是在游戏中！资源可以有很多种，从纹理、声音、着色器代码到句柄、字符串这些东西都可以被称为资源。资源的管理是项目中很重要的一轮，做得不好的话轻则内存泄漏、重则内存崩溃。RAII则是在C++项目中用于资源管理的一种重要的编程思想。</p>
<a id="more"></a>

<h2 id="先说一点C++">先说一点C++</h2>
<p>C++中不可或缺的东西就是class，而每个class不可或缺的就是构造函数和析构函数。前者用于对象被构造时进行的一系列操作，后者用于对象被析构时所执行的函数。</p>
<p>而值得一提的是，在C++中，如果一个类被声明在栈空间，则在该函数执行完毕从栈空间弹出之后，类会自动调用析构函数。可是如果被显示声明在堆空间（使用new方法或者malloc方法），则需要显式调用析构函数才能进行析构。</p>
<p>以上就是要读懂本篇博客所需要的C++知识，应该不难吧……</p>
<h2 id="总体概念">总体概念</h2>
<p>C++有很多很奇葩的名字，比如yacc，raii等，这算是一种悠久而自豪的传统吧2333333。</p>
<p>RAII是一个很典型的例子，它表示的是“资源获取即初始化”(Resource Aquisition Is Initialization)，而不是某些人认为的“初始化即资源获取”(Initialization is resource acquisition)。BTW，如果想搞怪，就怪到底吧，不然达不到效果。</p>
<p>RAII的技术很简单，利用C++对象生命周期的概念来控制程序的资源。它的技术原理很简单，如果希望对某个重要资源进行跟踪，那么创建一个对象，并将资源的生命周期和对象的生命周期相关联。这样一来C++自带的对象管理设施就可以来管理资源了。</p>
<h3 id="举个RAII栗子">举个RAII栗子</h3>
<p>最简单的形式：创建一个对象，让她的构造函数获取一份资源，而析构函数则释放这个资源：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Resource{...};</div><div class="line"><span class="keyword">class</span> ResourceHandle{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">         <span class="comment">// get resource</span></div><div class="line">         <span class="keyword">explicit</span> ResourceHandle(ResourceHandle *aResource ): r_(aResource){}</div><div class="line">        </div><div class="line">         <span class="comment">// release resource</span></div><div class="line">         ~ResourceHandle()</div><div class="line">         {</div><div class="line">             <span class="keyword">delete</span> r_;</div><div class="line">         }</div><div class="line">        </div><div class="line">         <span class="comment">// get access to resource</span></div><div class="line">        Resource *get()</div><div class="line">         {</div><div class="line">             <span class="keyword">return</span> r_;</div><div class="line">         }</div><div class="line">        </div><div class="line">    <span class="keyword">private</span>:</div><div class="line">         <span class="comment">// make sure it can not be copied by others</span></div><div class="line">        ResourceHandle (<span class="keyword">const</span> ResourceHandle &amp;);</div><div class="line">        ResourceHandle &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ResourceHandle &amp;);</div><div class="line">        Resource *r_;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>ResourceHandle对象的最好的地方就是：如果它被声明为一个函数的局部变量，或者作为一个参数，或者静态变量，我们都可以保证析构函数得到调用了。这样一来就可以释放对象所引用的资源。</p>
<h3 id="实际操作之反栗">实际操作之反栗</h3>
<p>我们看看一个没有使用RAII的简单代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> f() {</div><div class="line"></div><div class="line">    Resource *rh = <span class="keyword">new</span> Resource;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">if</span> (blahblah())</div><div class="line">         <span class="keyword">return</span> ;</div><div class="line">        </div><div class="line">    <span class="comment">//...</span></div><div class="line">    g();         <span class="comment">//catch the exceptions</span></div><div class="line">    </div><div class="line">    <span class="comment">// Can we make sure that it can be processed here?</span></div><div class="line">    <span class="keyword">delete</span> rh ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>就如同我在注释中的一样，可能一开始的时候上面那段代码是安全的，rh的资源总是可以被释放。</p>
<p>但是如果经历了一些维护呢？比如说上面的g()函数，有可能会造成函数的提前返回，所以就有可能运行不到最后一句释放资源的代码了，因此这段代码是危险的。</p>
<h3 id="实际操作之正栗">实际操作之正栗</h3>
<p>那么如果使用RAII的话呢？代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> f() {</div><div class="line"></div><div class="line">    ResourceHandle rh (<span class="keyword">new</span> Resource );</div><div class="line">    </div><div class="line">    <span class="comment">//Definitely ok</span></div><div class="line">    <span class="keyword">if</span> (blahblah())</div><div class="line">         <span class="keyword">return</span> ;</div><div class="line">    </div><div class="line">    <span class="comment">//catch an exception? Go ahead!</span></div><div class="line">    g();</div><div class="line">    </div><div class="line">    <span class="comment">//finally the resource would be released by c++ itself.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样一来RAII就使得代码就更加健壮了，因为只要是函数返回了，无论是通过何种途径，那么在返回的时候析构函数就会自动释放资源。</p>
<p>使用RAII只有一种情况无法保证析构函数得到调用，就是当ResourceHandle被动态分配到堆空间上了，这样一来就只能显示得调用delete ResourceHandle对象才能保证资源释放了，比如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResourceHandle *rhp = <span class="keyword">new</span> ResourceHandle(<span class="keyword">new</span> Resource);    </div></pre></td></tr></table></figure>

<p>那么此时就蛋疼了，因为动态分配的东西需要显示调用delete才能释放，所以上面的做法通常是危险的做法。安全的做法是将RAII的handle分配到栈空间去，此时就能够确保安全。</p>
<p>（全文完）</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | C++学习之RAII编程思想 | 在C++程序运行的过程中免不了要进行资源的分配——尤其是在游戏中！资源可以有很多种，从纹理、声音、着色器代码到句柄、字符串这些东西都可以被称为资源。资源的管理是项目中很重要的一轮，做得不好的话轻则内存泄漏、重则内存崩溃。RAII则是在C++项目中用于资源管理的一种重要的编程思想。]]>
    
    </summary>
    
      <category term="C++" scheme="http://pinghackers.com/tags/C/"/>
    
      <category term="game" scheme="http://pinghackers.com/tags/game/"/>
    
      <category term="RAII" scheme="http://pinghackers.com/tags/RAII/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web前后端分离开发思路]]></title>
    <link href="http://pinghackers.com/2014/11/16/front-and-back-seperation-development/"/>
    <id>http://pinghackers.com/2014/11/16/front-and-back-seperation-development/</id>
    <published>2014-11-15T16:50:44.000Z</published>
    <updated>2014-11-22T13:26:22.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="1-_问题的提出">1. 问题的提出</h2>
<p>开发一个Web应用的时候我们一般都会简单地分为前端工程师和后端工程师（注：在一些比较复杂的系统中，前端可以细分为外观和逻辑，后端可以分为CGI和Server）。前端工程师负责浏览器端用户交互界面和逻辑等，后端负责数据的处理和存储等。前后端的关系可以浅显地概括为：后端提供数据，前端负责显示数据。</p>
<p>在这种前后端的分工下，会经常有一些疑惑：<strong>既然前端数据是由后端提供，那么后端数据接口还没有完成，前端是否就无法进行编码？怎么样才能做到前后端独立开发？</strong></p>
<a id="more"></a>

<p>考虑这么一个场景：Alex和Bob是一对好基友，他们有个可以颠覆世界的idea，准备把它实现出来，但是他们不需要程序员，因为他们就是程序员。说干就干，两个就干上了。Alex写前端，Bob写后端。</p>
<p>Alex和Bob都经过良好的训练，按部就班地把产品的主要功能设计，交互原型，视觉设计做好了，然后他们根据产品功能和交互制定了一堆叼炸天的前后端交互的API，这套API就类似于一套前后端开发的“协议”，Alex和Bob开发的时候都需要遵守。例如其中一个发表评论的功能：</p>
<pre><code>// <span class="type">API</span>: <span class="type">Create</span> <span class="type">New</span> <span class="type">Comment</span> v2
// <span class="type">Ajax</span>, <span class="type">JSON</span>, <span class="type">RESTful</span>
url: /comments
<span class="keyword">type</span>: <span class="type">POST</span>
request: {content: <span class="string">"comment content."</span>, userId: <span class="number">123456</span>}
response: 
    - status: <span class="number">200</span>
        data: {<span class="literal">result</span>: <span class="string">"SUCCESS"</span>, msg: <span class="string">"The comment has been created."</span>}
    - status: <span class="number">404</span>
        data: {<span class="literal">result</span>: <span class="string">"failed"</span>, msg: <span class="string">"User is not found."</span>}
</code></pre><p>Alex的前端需要向<code>/comments</code>这个url以<code>POST</code>的方式发送类似于<code>{content: &quot;comment content.&quot;, userId: 123456}</code>这样的JSON请求数据；Bob的服务端识别后以后，操作成功则返回200状态和上面的JSON的数据，不同的操作状态有不同的响应数据（为了简单起见只列出了两种，200和404）。</p>
<p>API制定完以后，Alex和Bob就开始编码了。Alex把评论都外观和交互写完了，但是写到发表评论功能就纳闷了：Alex现在需要发Ajax过去，但是只能把Ajax代码写好，因为是本地服务器，却无法获取到数据：</p>
<pre><code>// jQuery <span class="type">Ajax</span>
$.ajax({ // 这个ajax直接报错，因为这个是<span class="type">Alex</span>的前端服务器，请求无法获取数据；
    url: <span class="string">"/comments"</span>,
    <span class="typedef"><span class="keyword">type</span>: "<span class="type">POST</span>",</span>
    <span class="typedef"><span class="keyword">data</span>: <span class="container">{<span class="title">content</span>: <span class="title">content</span>, <span class="title">userId</span>: <span class="title">userId</span>}</span>,</span>
    success: funtion(<span class="typedef"><span class="keyword">data</span>) <span class="container">{
        // 这里不会被执行
    }</span></span>
})
</code></pre><p>相比起来Bob就没有这个烦恼，因为后端是基于测试驱动开发，且后端可以轻易地模拟前端发送请求，可以对前端没有依赖地进行开发和测试。</p>
<p>Alex把这种情况和Bob说了，Bob就说，要不我们把代码弄到你本地前后端连接一下，这不就可以测试了吗。Alex觉得Bob简直是天才。</p>
<p>他们把前后端代码代码都部署到Alex的本地服务器以后，经过一系列的测试，调试，终于把这个API连接成功了。但是他们发现这个方法简直不科学：难道每写一个API都要把前后端链接测试一遍吗？而且，Alex的如果需要测试某个API，而Bob的这个API还没写好，Alex这个功能模块的进度就“阻塞”了。</p>
<p>后面还有168个API需要写，不能这么做。Alex和Bob就开始思考这个问题的解决方案。</p>
<h2 id="2-_解决思路">2. 解决思路</h2>
<p>在这个场景下，前后端是有比较强的数据依赖的关系，后端依赖前端的请求，前端依赖后端的响应。而后端可以轻松模拟前端请求（基本上能写后端的语言都可以直接发送HTTP请求），前端没有一个比较明显的方案来可以做到模拟响应，所以这里的需要解决的点就是：<strong>如何给前端模拟的响应数据</strong>。</p>
<p>先来一句非常形而上的话：如果两个对象具有强耦合的关系，我们一般只要引入第三个对象就可以打破这种强耦合的关系。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">Object1</span> <span class="comment">|</span>  &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">|</span> <span class="comment">Object2</span> <span class="comment">|</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>

               <span class="comment">Before</span>               


<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">Object1</span> <span class="comment">|</span>  &lt;<span class="literal">-</span><span class="literal">-</span> <span class="comment">✕</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">|</span> <span class="comment">Object2</span> <span class="comment">|</span>
<span class="comment">|</span>         <span class="comment">|</span>              <span class="comment">|</span>         <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>                          <span class="comment">|</span>    
    <span class="comment">|</span>       <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>        <span class="comment">|</span>    
    <span class="comment">|</span>       <span class="comment">|</span>         <span class="comment">|</span>        <span class="comment">|</span>    
    <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span> <span class="comment">Object3</span> <span class="comment">|</span> &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>    
            <span class="comment">|</span>         <span class="comment">|</span>             
            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>             

               <span class="comment">After</span>                
</code></pre><p>在我们上述开发的过程中，前后端的耦合性太强了，我们需要借助额外的东西来打破它们的耦合性。所以，在前后端接口定下来以后，<strong>我们根据接口构建另外一个Server，这个Server会一一响应前端的请求，并且根据接口返回数据</strong>。当然这些数据都是假数据。我们把这个Server叫做<em>Mock Server</em>，而Bob真正在开发的Server叫做<em>Real Server</em>。</p>
<pre><code>+-------------------+                     +-------------------+
<span class="string">|                   | +-------- ✕ ------&gt; |                   |</span>
<span class="string">|     Browser       |                     |    Real Server    |</span>
<span class="string">|                   | &lt;---+               |                   |</span>
+--------------+----+     <span class="string">|               +-------------------+</span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
           Request      Response                               
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|          |                                    </span>
               <span class="string">|     +----+--------------+                     </span>
               +---&gt; <span class="string">|                   |                     </span>
                     <span class="string">|    Mock Server    |                     </span>
                     <span class="string">|                   |                     </span>
                     +-------------------+                     
</code></pre><p>Mock Server是根据API实现的，但是是没有数据逻辑的，只是非常简单地返回数据。例如上面Alex和Bob的发表评论的接口在Mock Server上是这样的：</p>
<pre><code>// <span class="type">Mock</span> <span class="type">Server</span>
// <span class="type">Create</span> <span class="type">New</span> <span class="type">Comment</span> <span class="type">API</span>
route.post(<span class="string">"/comments"</span>, function(req, res) {
    res.send(<span class="number">200</span>, {<span class="literal">result</span>: <span class="string">"Success"</span>});
})
</code></pre><p>Alex在开发的时候向Mock Server发出请求，而不是向Bob的服务器发出请求：</p>
<pre><code>// <span class="type">Sending</span> <span class="type">Request</span> to <span class="type">Mock</span> <span class="type">Server</span>
// jQuery <span class="type">Ajax</span>
$.ajax({ 
    url: config.<span class="type">HOST</span> + <span class="string">"/comments"</span>,
    <span class="typedef"><span class="keyword">type</span>: "<span class="type">POST</span>",</span>
    <span class="typedef"><span class="keyword">data</span>: <span class="container">{<span class="title">content</span>: <span class="title">content</span>, <span class="title">userId</span>: <span class="title">userId</span>}</span>,</span>
    success: funtion(<span class="typedef"><span class="keyword">data</span>) <span class="container">{
        // <span class="type">OK</span>
    }</span></span>
})
</code></pre><p>注意上面的<code>config.HOST</code>，我们把服务器配置放在一个全局共用的模块当中：</p>
<pre><code><span class="comment">// Front-end Configuration Module</span>
<span class="keyword">var</span> config = modules.exports;
config.HOST = <span class="string">"http://192.169.10.20"</span> <span class="comment">// Mock Server IP</span>
</code></pre><p>那么上面我们其实是向IP为<code>http://192.169.10.20</code>的Mock Server发出请求<code>http://192.169.10.20/comments</code>发出POST的请求。</p>
<p>当Alex和Bob都代码写好了以后，需要连接调试了，Alex只要简单地改一下配置文件即可把所有的请求都转向Bob所开发的Real Server：</p>
<pre><code><span class="comment">// Front-end Configuration Module</span>
<span class="keyword">var</span> config = <span class="built_in">module</span>.exports;
<span class="comment">// config.HOST = "http://192.169.10.20" // Mock Server IP</span>
config.HOST = <span class="string">"http://changing-world-app.com"</span> <span class="comment">// Real Server Domain</span>
</code></pre><p>然后Alex和Bob就可以愉快地分离独立开发，而最后只需要联合调试就可以了。</p>
<p>总结一下基本上前后端分离开发包括下面几个步骤：</p>
<ol>
<li>根据功能制定前后端接口（API）。</li>
<li>根据接口构建Mock Server工程及其部署。</li>
<li>前后端独立开发，前端向Mock Server发送请求，获取模拟的数据进行开发和测试。</li>
<li>前后端都完成后，前后端连接调试（前端修改配置向Real Server而不是Mock Server发送请求）。</li>
</ol>
<p>当然要注意，如果接口修改了，Mock Server要同步修改。</p>
<h2 id="3-_实现方案">3. 实现方案</h2>
<p>Mock Server具体应该如何构建？应该存放在哪里？应该怎么维护？</p>
<p>前后端是不同的两个工程，它们各自占用一个仓库。Mock Server应该和它们分离出来，独立进行开发和维护，也就是说会有三个仓库，Mock Server是一个单独的工程。</p>
<p>Mock Server可以部署在本地，也可以部署到远程服务器，两者之间各有优劣。</p>
<hr>
<h3 id="3-1_远程Mock_Server">3.1 远程Mock Server</h3>
<p><strong>做法</strong>：把Mock Server工程部署到一个远程的always on的远程服务器上，前端开发的时候向该服务器发请求。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>没有给原有的前后端工程增加负担。</li>
<li>每个前端开发人员向同一个Mock Server服务器发送请求，保持所有人获取响应请求的一致性。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>有跨域问题（思考：locahost如何向192.169.10.20发请求？）。</li>
<li>需要额外的远程服务器支持。</li>
</ol>
<p>（在写这篇博客的时候，逛<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>，刚好看到有人做了一个开发辅助工具（<a href="http://reqr.es/" target="_blank" rel="external">http://reqr.es/</a>），可以用于开发时响应前端请求，其实也就是这里所说的远程Mock Server。真是不能再巧更多。）</p>
<h3 id="3-2_本地Mock_Server">3.2 本地Mock Server</h3>
<p><strong>做法</strong>：前端把Mock Server克隆到本地，开发的时候，开启前端工程服务器和Mock Server，所有的请求都发向本地服务器，获取到Mock数据。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>节约资源，不需要依赖远程服务器。环保节能。</li>
<li>没有跨域问题。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>增加前端工程开发流程复杂程度。</li>
<li>每个前端开发人员自己部署服务器在本地，可能会有仓库没有及时更新导致API不一致的情况。</li>
</ol>
<hr>
<p>Mock Server工程一般可以由后端开发人员来维护。因为在开发的过程中，后端因为各种原因可能需要修改API，后端人员是最熟悉请求的响应数据和格式的人，可以同步维护Mock Server和Real Server，更好保证数据的一致。Mock Server维护起来并不复杂，对于比较大多工程来说，这样的前期准备和过程的维护是非常值得的。</p>
<h2 id="最后">最后</h2>
<p>所以要点就是：<strong>根据API构建可以模拟服务器响应的Mock Server，用于前端请求模拟数据进行测试</strong>。</p>
<p>再重复总结一下前后端分离开发包括下面几个步骤：</p>
<ol>
<li>根据功能制定前后端接口。</li>
<li>根据接口构建Mock Server工程及其部署。</li>
<li>前后端独立开发，前端向Mock Server发送请求，获取模拟的数据进行开发和测试。</li>
<li>前后端都完成后，前后端连接调试。</li>
</ol>
<p>当开发只有我一个人的时候，我更喜欢后端独立开发，开发前端的时候开个Real Server来做响应。又爽又快。其实如果团队的人是full-stack的话，完全可以按照功能模块来划分任务，而不是分为前端工程师和后端工程师。</p>
<p>但一般来说还是会选择前后端职能划分，对于这种情况下的多人开发的工程来说，前后端分离开发的方式确实需要考虑和构建的，可以更好帮助我们构建一个高效，规范化，流程化的开发流程。</p>
<p>还是那句话，没有银弹，所有的东西都需要根据实际情况来构建独特的流程。</p>
<h2 id="References">References</h2>
<p> 无</p>
<p>（全文完）</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | Web前后端分离开发思路 | 开发一个Web应用的时候我们一般都会简单地分为前端工程师和后端工程师。前端工程师负责浏览器端用户交互界面和逻辑等，后端负责数据的处理和存储等。在这种前后端的分工下，会经常有一些疑惑：既然前端数据是由后端提供，那么后端数据接口还没有完成，前端是否就无法进行编码？怎么样才能做到前后端独立开发？]]>
    
    </summary>
    
      <category term="web" scheme="http://pinghackers.com/tags/web/"/>
    
      <category term="流程" scheme="http://pinghackers.com/tags/%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端自动化开发工作流模板]]></title>
    <link href="http://pinghackers.com/2014/11/08/front-end-workflow/"/>
    <id>http://pinghackers.com/2014/11/08/front-end-workflow/</id>
    <published>2014-11-08T02:00:24.000Z</published>
    <updated>2014-11-22T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<h2 id="1-_前言">1. 前言</h2>
<p>HTML5在前几天终于成为了W3C推荐的标准，让Web开发者们非Web开发者们和不知道是什么但是看起来很厉害于是一起起哄的人高潮了一顿，普天同庆。</p>
<p>其实没什么好high的，在2008年HTML5就完成了draft。早在2011年W3C就设了一个2014年完成标准的milestone。我大一毛都没长齐的时候就听师兄们说：”你毕业的时候HTML5就会完成并成为标准啦啦啦。” W3C只是完成了它们的计划而已。而且，这几年人们早就都把HTML5、CSS3用得出神入化了。</p>
<p>不过随着HTML5、ES6这些东西成为标准，还有最近世界上聪明的头脑们在Web方面进行的先烈和先驱般的探索，层出不穷的新语言、新技术、新框架，原来混沌的世界逐渐被开辟出一片天地。原来杂乱无章的Web前端开发过程也叫嚷着要规范化、标准化。随着众神们的努力，我相信很快，我们写一次前端代码就可以完美地在除了IE以外的各个浏览器中运行（脑洞有点大）。</p>
<p>扯得有点远，其实上面说的内容和我要介绍的东西无关。本文会介绍我常用的一种前端开发工作流程，并且提供一个模板，有兴趣的同学可以修改成适合自己的。</p>
<h2 id="2-_前端自动化工作流简介">2. 前端自动化工作流简介</h2>
<p>每种项目都有自己特定的开发流程、工作流程。从需求分析、设计、编码、测试、发布，一个整个开发流程中，会根据不同的情况形成自己独特的步骤和流程。一个工作流的过程不是一开始就固定的，而是随着项目的深入而不断地改进，期间甚至会形成一些工具。例如当年大神们在Linux写C语言，觉得每次编译好多文件好麻烦，就发明了makefile。不同代码的管理好麻烦，然后就发明了git、SVN等等。</p>
<p>一个工作流程的好坏会影响你开发的效率、开发的流程程度，然后间接影响心情，打击编码积极性。所以我认为开发一个项目的时候，编码前把工作流程梳理清楚确定下来是一个非常重要的步骤。并且这个流程要在真实环境中不停的改进。</p>
<p>对于要负责页面结构和内容、外观、逻辑的前端来说，一个好的工作流至关重要。而且这里中没有银弹。要根据具体项目所使用的框架、应用场景来进行调整独特的工作流。</p>
<p>我会介绍一个我经常使用的前端工作流，这个工作流只是一个原始的流程，一般来说，我会根据不同项目的不同来在这个基础上进行调整，形成每个项目独特的流程。所以这里的重点是领会构建工作流的思路，然后学会举一反三。</p>
<p>一个前端自动化开发流程中，我觉得至少需要做到以下几点：</p>
<ol>
<li>良好的模块化</li>
<li>自动化编译</li>
<li>自动化测试</li>
<li>实时刷新页面</li>
<li>自动化打包、压缩发布</li>
</ol>
<p>能用机器的地方就不要自己动手，除了上述必备的几点，有时候要根据特定的情况编写一些Python、Nodejs、Shell脚本来避免重复的操作。好好呵护你的F5和稀疏的脑神经，男人要对自己好一点。</p>
<a id="more"></a>

<h2 id="3-_储备知识">3. 储备知识</h2>
<p>在正式介绍之前会先做一些储备知识的介绍，也会略过一些你可能不懂的知识。懂的话可以跳过，遇到不懂的可以自己Google，不要百度。</p>
<h3 id="3-1_工程目录">3.1 工程目录</h3>
<p>我的工程目录一般是这个样的：</p>
<pre><code>├─assets/
│  └─images/
├─bin/
├─dist/
├─lib/
├─src/
│  ├─coffee/
│  │  └─main.coffee
│  └─less/
│     └─main.less
├─test/
│   └─specs/
├─node_modules/
├─<span class="keyword">index</span>.html
├─Gruntfile.coffee
├─<span class="keyword">package</span>.json
├─.gitignore
└─README.md
</code></pre><p>所有子目录名称很多都其实源于古老的C语言工程。</p>
<p><strong>assets</strong>：一般存放的是图片、音频、视频、字体等代码无关的静态资源，我一般只有图片，有时候也会新建一个fonts文件夹什么的。</p>
<p><strong>bin</strong>：binary的缩写，这个名字来历于我们古老的C语言工程，因为一般C语言要编译成可执行的二进制文件什么的，后来基本成为了一种默认的标注。所以前端编译好的文件也会存放在bin/目录下。</p>
<p><strong>dist</strong>：distribution的缩写，编译好的bin中的文件并不会直接用于发布，而是会经过一系列的优化操作，例如打包压缩等。最终能够部署到发布环境的文件都会存放在dist里面，所以dist里面是能够直接用到生产环境的代码。</p>
<p><strong>lib</strong>：library的缩写，存放的是第三方库文件。例如你喜欢的jquery、fastclick什么的。但是接下来你会看到，在我们的模块化方式中，这个文件夹一般是比较鸡肋的存在。</p>
<p><strong>src</strong>：source的缩写，所有需要开发的源代码的存放地，我们一般操作地最多的就是这个文件夹。简单地分为coffee、less两个文件夹，存的是逻辑代码和样式（我一般用CoffeeScript和LessCss，当然你也可以改成你喜欢的语言，JS，TS，LS，SASS，思路是一样的）。你看到两个文件夹下分别有main.coffe、main.less，这其实是逻辑代码和样式代码的主要入口文件，会把其他模块和样式引进来，通过某种机制合成一个文件。接下来会详细解释。</p>
<p>另外，这个目录的组织方式会根据实际情况多变。有时候你会需要html模板，可能会多一个tpl/目录。也许你的目录不是这种基于文件类型的层次组织，而是基于页面部件的组织，就可能出现components/目录，然后下面有很多个页面部件的目录，每个子目录有自己的coffee、less、html。（这种形式也变得逐渐流行。因为基于文件类型目录，当工程复杂起来的时候，就会变得异常难以维护，基于部件就会相当方便）。</p>
<p><strong>test</strong>：使用测试驱动（TDD）开发进行编程，这里存放的都是测试样例。</p>
<p><strong>index.html</strong>：页面文件</p>
<p>接下来几个文件都不解释，不了解的可以先预习NodeJS、Git、Grunt这几个东西。</p>
<h3 id="3-2_模块化">3.2 模块化</h3>
<p>说起前端模块化又是一个可以长篇大论话题。前端模块化的方式有很多种，年轻人最喜欢用的就是RequireJS、SeaJS什么的，看到这些模块化工具的时候感觉就像自己的第一双滑板鞋那样那么兴奋。其实这种AMD、CMD都需要引进一个库文件来做模块化工具，而且配置复杂，各种异步加载问题多多。后来我发现其实最clean、直接、方便、强大模块化方式当属<a href="http://substack.net" target="_blank" rel="external">substack</a>大神的真.<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>。</p>
<p><img src="http://browserify.org/images/browserify.png" alt="block"></p>
<p>它可以基于NodeJS平台实现模块化的工具，你可以像组织NodeJS代码那样组织自己的前端工程，所有的模块都可以像NodeJS那样直接require进来。提供一个入口文件（如上的main.coffee)给Browserify，它会把这个入口文件的所有依赖模块都打包成一个文件。最终的文件不依赖于Browserify，最终的文件就是你的逻辑代码的组合。</p>
<p>而且Browserify和NodeJS的模块兼容性很好，一些NodeJS自带的模块例如util、path都可以用到前端中。你用npm安装的库，也可以通过Browserify用到前端中！例如我想用jQuery，我只需要：<code>npm install jquery --save</code>。然后在main.coffee中：</p>
<pre><code><span class="variable">$ </span>= <span class="keyword">require</span> <span class="string">"jquery"</span>
/<span class="regexp">/ play with jquery</span>
</code></pre><p>相当贴心。</p>
<p>（Browserify具体用法查看<a href="http://browserify.org/" target="_blank" rel="external">官网文档</a>）</p>
<h3 id="3-3_流程自动化工具">3.3 流程自动化工具</h3>
<p>其实自动化方式可以有很多种，你可以：</p>
<ul>
<li>配置npm的script，直接用npm来进行自动化任务管理。</li>
<li>使用古老的makefile和shell脚本</li>
<li>Grunt</li>
<li>Gulp</li>
</ul>
<p>前两种方式更适合NodeJS开发服务端的应用场景，前端一般更适合用后两种。</p>
<p>目前使用的是<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>，选择它是因为它社区大、插件多、成熟。但是我更看好Gulp基于流(Stream)的机理，这种继承于Unix思想的无与伦比的实现方式着实可以让它在性能上和Grunt拉开差距。Grunt基于文件实现方式是在是：太！慢！了!</p>
<p>（Grunt具体用法可以见<a href="http://gruntjs.com/" target="_blank" rel="external">官网文档</a>）</p>
<h3 id="3-4_测试">3.4 测试</h3>
<p>测试又是一个庞大的话题。在国外，前端TDD、BDD开发已经相当成熟，各种酷炫的工具Jasmine、Mocha、Tape等等，可能是我比较孤陋寡闻，貌似国内很少见到这些工具的使用。</p>
<p>其实前端是很难做到完全测试驱动开发的，它本身涉及到许多主观判断因素，例如动画是不是按照预想的那样移动等等。但是<strong>逻辑代码</strong>和<strong>前后端接口</strong>逻辑是可以测试的。所以引进测试驱动开发的一个非常大的好处就是：只要接口确定了，前后端可以分离开发，前端不用再“等后端API实现”了。</p>
<p>在我们的工作流中，使用<a href="http://mochajs.org/" target="_blank" rel="external">MochaJS</a>作为测试套件，<a href="http://chaijs.com/" target="_blank" rel="external">ChaiJS</a>作为断言库，<a href="http://sinonjs.org/" target="_blank" rel="external">Sinon</a>做为数据mocking和函数spy。具体用法可以看各自的官网。</p>
<p>（对前端测试驱动开发不了解的同学可以Google相关资料或查阅相关书籍）</p>
<h2 id="4-_自动化工作流">4. 自动化工作流</h2>
<h3 id="4-1_模板">4.1 模板</h3>
<p>这个工作流的模版已经存放到了github上，大家可以clone下来进行本地测试一下：<a href="https://github.com/livoras/feb.git" target="_blank" rel="external">https://github.com/livoras/feb.git</a></p>
<p>运行步骤：</p>
<ol>
<li>电脑上必须先按安装好Nodejs和npm</li>
<li><p>安装browswerify，coffeescript，和grunt：</p>
<p> npm install browswerify coffee-script grunt-cli -g</p>
</li>
<li><p>把仓库fork到本地，进入工程目录，安装依赖：</p>
<p> npm install</p>
</li>
<li><p>然后运行grunt命令</p>
</li>
</ol>
<p>运气好的话你可以看到这样的界面:</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/grunt.png"></p>
<p>然后，你会发现工程目录下多了一个bin文件夹，那就是我们刚编译好的文件存放在bin中。</p>
<p>然后打开浏览器，进入<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> ，可以看到：<br><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/localhost.png"></p>
<p>现在我们修改src/less/main.less文件，把body改成黑色看看：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/less.png"></p>
<p>然后回到浏览器看看：<br><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/black-localhost.png"></p>
<p>说变就变，非常哦妹子（amazing）是不是？</p>
<p>工作流分两个简单的步骤：</p>
<ol>
<li>开发时</li>
<li>分布时 </li>
</ol>
<p>现在来介绍一下。</p>
<h3 id="4-2_开发时">4.2 开发时</h3>
<p>我们来看看gruntfile的100～108行：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/gruntfile.png"></p>
<p>其实grunt干了这么几件事：</p>
<ol>
<li><strong>开启本地服务器进行调试</strong>：使用grunt的一个connect插件，开启了一个本地服务器，localhost:3000，工程目录为根目录。</li>
<li><strong>删除原来已经之前已经过时的编译文件</strong>：删除整个bin文件夹</li>
<li><strong>编译coffeescript并且使用browserify进行依赖合并</strong>：将src/coffee/下面的main.coffee作为入口，把所有依赖模块编译成js并且合并成一个文件，存放到bin/js/目录下。打开bin/js/你可以看到下面有一个main.js。细心但话，你会发现，其实main.coffee是依赖同目录下的一个叫another-module.coffee的模块的。在编译的时候，browserify会分析整个main.coffee的依赖树，然后找到所有依赖进行合并，所以你看到的bin/js/main.js其实是包含了两个模块的内容。所以我们可以用Nodejs的方式写模块，前端只需要合并好的文件就可以了。</li>
<li><strong>编译less</strong>：将src/less/main.less编译到bin/css/目录下，同样的， Less也是可以类似coffee的方式引用模块（通过<code>import</code>）。所以我们的样式也是萌萌哒模块化了。</li>
<li><strong>运行测试</strong>：所有的测试存放在test/specs下，编译好以后，grunt会运行moch运行测试样例。你在窗口中可以看到我们一共有三个测试运行并且通过了。</li>
<li><strong>监控文件变化，一旦文件变化，重新执行3～5步骤。并且自动刷新浏览器</strong>：借助于grunt的watch插件，我们可以做到一旦文件修改的时候，就重新编译coffeescript，less，运行测试，并且自动刷新浏览器。</li>
</ol>
<p>有了这么一个流程，你就可以很轻松地写前端的逻辑和样式，并且都是以模块化的方式。</p>
<h3 id="4-3_发布时">4.3 发布时</h3>
<p>好了，代码都写完了。我需要把我的代码部署到服务器上。很简单，只需要命令行中执行：</p>
<pre><code><span class="title">grunt</span> build
</code></pre><p>你就会发现工程目录下多了一个dist文件夹，进入里面，可以看到：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/dist.png"></p>
<p>直接打开index.html：</p>
<p><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/dist-index.png"></p>
<p>居然可以直接打开，也是非常哦妹子是不是？</p>
<p>我们看看grunt的build任务：<br><img class="middle" src="https://raw.githubusercontent.com/livoras/blog-images/master/grunt-build.png"></p>
<p>grunt build干了这么几件事情：</p>
<ol>
<li>删除之前编译过的文件，同上。</li>
<li>删除之前发布的文件，也就是删除整个dist目录。</li>
<li>编译coffee和less，同上。</li>
<li>测试，发布前还是需要看看有没有问题嘛。</li>
<li>uglify，把bin/js/main.js混淆压缩，放到dist/js/下。</li>
<li>cssmin，把bin/css/main.css混淆压缩，放到dist/css下。</li>
<li>复制assets目录到dist下</li>
<li>复制index.html，做一些处理（更改相对路径等），存放到dist/下</li>
</ol>
<p>你可以看到dist目录下的文件js和css文件都是经过压缩的，现在dist中的文件夹已经ready了，你随时都可以直接放到服务器上了。</p>
<h2 id="5-_最后">5. 最后</h2>
<p>上面其实是一个非常简陋的流程，在实际要做的流程化要比这个复杂多，例如要考虑组建目录自动化构建，版本管理自动化，部署自动化，图片合并优化等等。主要有这个意识：<em> <strong>不要做任何重复的工作，能自动化到地方都可以想法设法做到自动化</strong> </em>。</p>
<p>上面也跳过了很多基础知识，这些是你需要知道的：</p>
<ol>
<li>Grunt的使用</li>
<li>Nodejs的基本使用</li>
<li>模块化概念</li>
<li>TDD测试的概念和基本测试套件的使用</li>
<li>Coffee，Less，Browserify但使用等</li>
</ol>
<p>我甚至直接跳过了构建整个流程的过程，也跳过了测试如何编写。其实其中很多细节都可以拓展来讲，测试，模块化等，接下来博客也许会往这个方向去写。</p>
<p>（全文完）</p>
<style>img.middle{width: 65%;display: block;border: 1px solid #ccc;}</style>]]></content>
    <summary type="html">
    <![CDATA[PingHackers | 前端自动化开发工作流模板 | 每个项目都有自己特定的开发流程、工作流程。从需求分析、设计、编码、测试、发布，一个整个开发流程中，会根据不同的情况形成自己独特的步骤和流程。前端工程也不例外，本文总结前端的一个工作流模版供参考。]]>
    
    </summary>
    
      <category term="web" scheme="http://pinghackers.com/tags/web/"/>
    
      <category term="前端" scheme="http://pinghackers.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unix哲学与Node.js]]></title>
    <link href="http://pinghackers.com/2014/11/01/unix-and-nodejs/"/>
    <id>http://pinghackers.com/2014/11/01/unix-and-nodejs/</id>
    <published>2014-11-01T04:04:50.000Z</published>
    <updated>2014-11-22T13:24:27.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者</strong>：戴嘉华</p>
<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>
<hr>
<p>翻译自：<a href="http://blog.izs.me/post/48281998870/unix-philosophy-and-node-js" target="_blank" rel="external">Unix Philosophy and Node.js</a>。</p>
<hr>
<p><strong>[译注]</strong></p>
<p>在软件这个迭代更新迅速的领域，Unix不得不说是一个奇葩中的奇葩，自从设计完成以后以来基本上没有做过太多的修改，但是却持续地发光发热了几十年，支撑它的不仅仅是它精妙的设计，还有前辈们因为Unix而奠定的Unix哲学，影响了不仅仅是一个操作系统，而是几代Hackers的对程序的理解，对架构的设计。你几乎可以在那些最优秀的Hackers写的每一行代码中看到Unix哲学的身影。</p>
<p>本文的作者<a href="http://blog.izs.me" target="_blank" rel="external">isz</a>是<a href="https://github.com/npm/npm" target="_blank" rel="external">npm</a>（Node.js包管理器）的主要代码贡献者，在他的文章中，可以窥见Unix哲学对Node.js设计，文化所产生的影响。</p>
<p><img src="https://raw.githubusercontent.com/livoras/blog-images/master/alice.jpg" alt="block"></p>
<p>以下是正文：</p>
<hr>
<p>在TxJS的另外一天，我做了一个演讲，提到了Unix哲学是Node.js的模式、主张、和文化很重要的一部分。像往常一样，在视频流出之前，我提前把展示用到的<a href="http://j.mp/node-patterns-pdf" target="_blank" rel="external">幻灯片</a>放网上。</p>
<p>出于某些原因，简短地提及“Unix哲学”引起了一些人的忿怒。当时我只有25分钟，但是我讲的每一页幻灯片都可以单出拿出来做一个演讲，所以我只好尽量地把精华抽出来讲。视频不能很好地还原当时的场景。但是我的目的是能够引起大家的讨论，所以如果它引起了一些批评，也许我的目标就达到了。毕竟，无知地唱高调只适合说教，我想我最好解释一下。</p>
<a id="more"></a>

<p>Eirc S. Raymond在他的<em><a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html" target="_blank" rel="external">The Art Of Unix Programming</a></em>收集了一些关于Unix哲学的最佳阐述。他详细讨论了17条特定的原则，但是我最喜欢的关于Unix哲学的阐述是Salus在他的<em>A Quarter Century of Unix</em>引用Doug McIlroy的简洁的陈述：</p>
<blockquote>
<p>这就是Unix的哲学：</p>
<p>写只做一件事并且把这件事做好的程序。</p>
<p>写能组合在一起运作的程序。</p>
<p>写能处理文本流的程序，因为文本流是通用的接口。</p>
</blockquote>
<p>McIlroy接下来稍微详细地给出了4点自己的陈述：</p>
<blockquote>
<p>(i) 每个程序只做好一件事情。当需要完成新的任务的时候，写一个新的程序而不是原有程序上添加新功能。</p>
<p>(ii) 让每一个程序的输出可以成为另外一个程序的输入，甚至是未知的程序的输入。不要在输入中混杂着无用的信息。避免严格按列排列二进制的输入格式。不要依赖交互式输入。</p>
<p>(iii) 在设计和编写软件，甚至是操作系统的时候，要尽快地尝试，最好是在几个星期之内就完成。要毫无顾虑地删掉笨拙的地方和重写它们。（译注：深有体会，绝B认同。）</p>
<p>(iv) 使用工具而不是蹩脚的编码来减轻编程任务，即使你知道你最后还是不得不自己来构建这些工具或者要放弃它们。</p>
</blockquote>
<p>在X桌面系统（译注：X是Linux下的桌面系统，没有它Linux就没有界面了）Mike Gancarz把Unix哲学总结成了9点：</p>
<blockquote>
<ol>
<li>精小就是优雅。</li>
<li>让每个程序只做好一件事情。</li>
<li>尽快地完成原型。</li>
<li>可移植性高于效率。</li>
<li>用纯文本来存放数据。</li>
<li>使用软件来加强你的优势。</li>
<li>使用Shell脚本来提高利用率和可移植性。</li>
<li>不要迷恋界面。</li>
<li>让每一个程序都成为过滤器。</li>
</ol>
</blockquote>
<p>最后一点和Ryan Dahl（译注：Node.js作者）经常说的“一切程序都是代理”（Every program is a proxy）产生了强烈的共鸣。前三点其实是<a href="http://substack.net/" target="_blank" rel="external">James Halliday</a>（译注：花名substack，疯了一样贡献了几百个Node.js模块，Node.js届无人不知的巨巨）的赖以生存的法则。</p>
<p>人们经常错误地迷失在Unix哲学的某些方面，而通常一叶障目不见森林。Unix哲学并不是一种特定的程序实现，或某种Unix操作系统或程序特有的东西。它并不是文件描述符，管道，套接字，或者信号量。这些误解就像是，除非一个人说<a href="http://en.wikipedia.org/wiki/Pali" target="_blank" rel="external">Pali语</a>，否则就不是佛教徒一样。</p>
<p>Unix哲学是软件开发的曙光，而不是软件中的一种特定技术开发。它是一种值得我们追求的理想境界，也许听起来有点讽刺：它是一种让指引我们要注重实用性而不是理想主义的理想境界。</p>
<p>在Node里面，人们之间分享和交互基本的构建的单元不是命令行中的二进制数据，而是通过<code>require</code>加载进来的模块。文本流<em>是</em>通用的接口，在Node.js里面其实就是JavaScript流对象，而不是标准输入输出中的管道。（标准输入输出的管道当然也在JavaScript流对象中体现出来了，因为它是我们通用的接口，我们还有其他选择吗？）</p>
<p>所以就从JavaScript的角度来说，我会说一下我是怎么表述Unix哲学的。哎～可惜我不是McIlroy，我也没有时间和能力去把它写得更精简，大家就将就一下吧：</p>
<blockquote>
<p>写只做好一件事的模块。写新的模块而不是增加旧的模块的复杂性。</p>
<p>写鼓励组合而不是鼓励扩展的模块。</p>
<p>写能够处理数据流的模块，因为它是通用的接口。</p>
<p>写对数据来源和去向都无知的模块。</p>
<p>写某块来解决你知道的问题，那么你就可以知道哪些问题你是不知道的。</p>
<p>写小的模块。迅速地迭代。无情地重构。勇敢地重写。</p>
<p>迅速地写模块来满足你的需求，写几个测试来合乎规范。避免臃肿的文档。为你fix掉的每个bug写测试。</p>
<p>能工作优于完美</p>
<p>功能专注优于功能丰富</p>
<p>兼容性优于纯粹性</p>
<p>简单优于任何东西</p>
</blockquote>
<p>Unix哲学是一种实用主义意识形态。是关于如何在写<em>好的软件</em>和写<em>任何软件</em>这两种需求中取得平衡。它是一套实用的建议，牺牲开发成本中的稳健性来获取更低的维护成本。</p>
<p>在现实世界当中，作为人类，我们在编写和调试程序的时候面临这一种相当不公平的约束，编码和调试的成本永远不可能降低到0。这种观念是有情景的，并且可以应用到所有的层次当中。我们都承认，我们没有聪明到写一次就知道如何把我们要写的软件写对，因为只有当我们把问题解决的时候我们才能完全理解问题。</p>
<p><strong>不是所有规则都是神圣不可侵犯的！</strong>事实上，在很多情景下面，这些规则都是有争议甚至有时候是完全相反的。即便这样，如果我们把让我们程序的单元保持精小，加以简单通用的接口，我们就可以把所有零散的部件组合成一个高品质的齿轮，那么在我们滚动的时候，可以轻松自在地把笨拙的部分换出去。</p>
<p>没有线索清晰地表明Unix哲学和软件分享文化有什么关系。但是，它无疑是来自于我们一直在其中讨论如何让我们的软件更加自由的社区。根据这些原则来开发的软件，会更加容易地被分享，重用，重改和维护。</p>
<p>（完）</p>
]]></content>
    <summary type="html">
    <![CDATA[PingHackers | Unix哲学与Node.js | 在软件这个迭代更新迅速的领域，Unix不得不说是一个奇葩中的奇葩，自从设计完成以后以来基本上没有做过太多的修改，但是却持续地发光发热了几十年，支撑它的不仅仅是它精妙的设计，还有前辈们因为Unix而奠定的Unix哲学，影响了不仅仅是一个操作系统，而是几代Hackers的对程序的理解，对架构的设计。]]>
    
    </summary>
    
      <category term="unix" scheme="http://pinghackers.com/tags/unix/"/>
    
      <category term="nodejs" scheme="http://pinghackers.com/tags/nodejs/"/>
    
      <category term="翻译" scheme="http://pinghackers.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
